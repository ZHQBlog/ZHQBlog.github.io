

<!DOCTYPE html>
<html lang="zh_CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="倔强的小强">
  <meta name="keywords" content="倔强的小强">
  
    <meta name="description" content="常用指令，数据类型，通用指令，Jedis，持久化，Redis事务，删除策略，数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2021/11/16/Redis/index.html">
<meta property="og:site_name" content="小强的博客">
<meta property="og:description" content="常用指令，数据类型，通用指令，Jedis，持久化，Redis事务，删除策略，数据结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/11/16/Redis/Redis/image-20220402231459951.png">
<meta property="og:image" content="http://example.com/2021/11/16/Redis/Redis/image-20220402231509749.png">
<meta property="og:image" content="http://example.com/2021/11/16/Redis/Redis/image-20220402231519830.png">
<meta property="og:image" content="http://example.com/Redis/image-20220402231537723.png">
<meta property="og:image" content="http://example.com/2021/11/16/Redis/Redis/image-20220402231541245.png">
<meta property="og:image" content="http://example.com/2021/11/16/Redis/Redis/image-20220402231550506.png">
<meta property="og:image" content="http://example.com/2021/11/16/Redis/Redis/image-20220402231605922.png">
<meta property="og:image" content="http://example.com/2021/11/16/Redis/Redis/image-20220402231618214.png">
<meta property="og:image" content="http://example.com/2021/11/16/Redis/Redis/image-20220402231627461.png">
<meta property="og:image" content="http://example.com/2021/11/16/Redis/Redis/image-20220402231639618.png">
<meta property="og:image" content="http://example.com/2021/11/16/Redis/Redis/image-20220402231651540.png">
<meta property="og:image" content="http://example.com/2021/11/16/Redis/Redis/image-20220402231700831.png">
<meta property="og:image" content="http://example.com/2021/11/16/Redis/Redis/image-20220402231713881.png">
<meta property="og:image" content="http://example.com/2021/11/16/Redis/Redis/image-20220402231733279.png">
<meta property="article:published_time" content="2021-11-16T11:03:57.000Z">
<meta property="article:modified_time" content="2022-04-02T15:17:37.602Z">
<meta property="article:author" content="倔强的小强">
<meta property="article:tag" content="倔强的小强">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2021/11/16/Redis/Redis/image-20220402231459951.png">
  
  
  <title>Redis - 小强的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>❤</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Startseite
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archiv
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Kategorien
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Schlagwörter
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                Über
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Redis"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-11-16 19:03" pubdate>
          2021年11月16日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k wörter
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          157 minuten
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis</h1>
            
            <div class="markdown-body">
              
              <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><em><strong>Redis</strong></em> 是典型的 <em><strong>NoSQL</strong></em> 数据库。</p>
<p><em><strong>redis官网</strong></em>：<a target="_blank" rel="noopener" href="https://redis.io/download">https://redis.io/download</a></p>
<blockquote>
<p>Redis 是一个开源的 key-value 存储系统。</p>
<p>和 Memcached 类似，它支持存储的 value 类型相对更多，包括 string、list、set、zset、sorted set、hash。</p>
<p>这些数据类型都支持 push&#x2F;pop、add&#x2F;remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p>
<p>在此基础上，Redis 支持各种不同方式的排序。</p>
<p>与 memcached一样，为了保证效率，数据都是缓存在内存中。</p>
<p>区别的是 Redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p>
<p>并且在此基础上实现了master-slave （主从）同步。</p>
<p>单线程 + IO 多路复用。</p>
</blockquote>
<h2 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h2><p><strong>运行在linux系统上，默认端口号：6379</strong></p>
<p>安装 C 语言的编译环境和redis，解压redis并在给目录下执行 make</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make &amp;&amp; make install<br></code></pre></td></tr></table></figure>

<p>默认安装在 <code>/usr/local/bin</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-benchmark：性能测试工具，可以在自己本子运行，看看自己本子性能如何<br>redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲<br>redis-check-dump：修复有问题的dump.rdb文件<br>redis-sentinel：Redis集群使用<br>redis-server：Redis服务器启动命令<br>redis-cli：客户端，操作入口<br></code></pre></td></tr></table></figure>

<p>前台启动：***&#x2F;usr&#x2F;local&#x2F;bin*** 目录下启动 <em><strong>redis</strong></em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-server(前台启动)<br></code></pre></td></tr></table></figure>

<p>后台启动：</p>
<ul>
<li><p>安装 <em><strong>redis</strong></em> 的目录 <em><strong>&#x2F;opt&#x2F;redis-6.2.6</strong></em> 中将 <em><strong>redis.conf</strong></em> 复制到任意一个文件夹下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> redis.conf /etc/redis.conf<br></code></pre></td></tr></table></figure>
</li>
<li><p>修改 <em><strong>&#x2F;etc&#x2F;redis.conf</strong></em> 配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim redis.conf<span class="hljs-comment"># daemonize no 修改为 daemonize yes</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><em><strong>&#x2F;usr&#x2F;local&#x2F;bin</strong></em> 目录下启动 <em><strong>redis</strong></em>，并进入客户端操作redis</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-server /etc/redis.conf<br>redis-cli -a 4213<br></code></pre></td></tr></table></figure></li>
</ul>
<p>关闭 ：</p>
<ul>
<li><em><strong>kill</strong></em> 进程</li>
<li>在redis-cli客户端使用命令 <em><strong>shutdown</strong></em></li>
</ul>
<h2 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h2><ul>
<li>解决 <em><strong>CPU</strong></em> 及内存压力</li>
<li>解决 <em><strong>IO</strong></em> 压力</li>
</ul>
<p>NoSQL，意即不仅仅是 SQL，泛指非关系型的数据库</p>
<p>NoSQL 不依赖业务逻辑方式存储，而以简单的 <em><strong>key-value</strong></em> 模式存储，因此大大的增加了数据库的扩展能力</p>
<ul>
<li>不遵循 <em><strong>SQL</strong></em> 标准</li>
<li>不支持 <em><strong>ACID</strong></em></li>
<li>远超于 <em><strong>SQL</strong></em> 的性能</li>
</ul>
<p><strong>适用于的场景</strong></p>
<ul>
<li>对数据高并发的读写</li>
<li>海量数据的读写</li>
<li>对数据高可扩展性的</li>
</ul>
<p><strong>不适用的场景</strong></p>
<ul>
<li>需要事务支持</li>
<li>基于 <em><strong>sql</strong></em> 的结构化查询存储，处理复杂的关系，需要级联查询</li>
</ul>
<p><strong>大数据时代常用的数据库类型</strong></p>
<ul>
<li><p>行式数据库：将数据表中一行数据放在一个块中</p>
</li>
<li><p>列式数据库：将数据表中一列（相同属性）数据放在一个块中</p>
</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><strong>redis.conf</strong></p>
<h3 id="Units"><a href="#Units" class="headerlink" title="Units"></a>Units</h3><p>单位，开头定义了一些基本的度量单位，只支持 bytes，不支持 bit</p>
<p>大小写不敏感</p>
<h3 id="INCLUDES"><a href="#INCLUDES" class="headerlink" title="INCLUDES"></a>INCLUDES</h3><p>包含，多实例的情况可以把公用的配置文件提取出来</p>
<h3 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a>NETWORK</h3><p>网络相关配置</p>
<p><em><strong>bind</strong></em>：默认情况 <code>bind=127.0.0.1</code> 只能接受本机的访问请求，注释的情况下，无限制接受任何 ip 地址的访问</p>
<p><strong>protected-mode</strong>：将本机访问保护模式设置 no</p>
<p>开启protected-mode，在没有设定 bind ip 且没有设密码的情况下Redis 只允许接受本机的响应</p>
<p><em><strong>port</strong></em>：端口号，默认 6379</p>
<p><strong>tcp-backlog</strong>：设置 tcp 的 backlog，backlog 其实是一个连接队列，backlog 队列总和 $&#x3D;$ 未完成三次握手队列 $+$ 已经完成三次握手队列</p>
<p><strong>timeout</strong>：一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能。即永不关闭</p>
<p><strong>tcp-keepalive</strong>：对访问客户端的一种心跳检测，每 n 秒检测一次；单位为秒，如果设置为 0，则不会进行 Keepalive检测，建议设置成 60</p>
<h3 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a>GENERAL</h3><p>通用</p>
<p><strong>daemonize</strong>：是否为后台进程，设置为 yes（守护进程，后台启动）</p>
<p><strong>pidfile</strong>：存放 pid 文件的位置，每个实例会产生一个不同的pid 文件</p>
<p><strong>loglevel</strong>：指定日志记录级别，Redis 支持四个级别：debug、verbose、notice、warning，默认为 notice</p>
<p><strong>logfile</strong>：日志文件名称</p>
<p><strong>database</strong>：设定库的数量 默认16，默认数据库为 0，可以使用 <code>SELECT &lt;dbid&gt;</code> 命令在连接上指定数据库 id</p>
<h3 id="SECURITY"><a href="#SECURITY" class="headerlink" title="SECURITY"></a><strong>SECURITY</strong></h3><p>安全</p>
<p>访问密码的查看、设置和取消</p>
<p>在命令中设置密码，只是临时的，重启 redis 服务器，密码就还原了，永久设置，需要在配置文件中进行设置</p>
<h3 id="LIMITS"><a href="#LIMITS" class="headerlink" title="LIMITS"></a><strong>LIMITS</strong></h3><p>限制</p>
<p><em><strong>maxclients</strong></em>：设置 redis 同时可以与多少个客户端进行连接，默认情况下为 10000 个客户端，达到了此限制，redis 则会拒绝新的连接请求，并且向这些连接请求方发出 max number of clients reached 以作回应</p>
<p><em><strong>maxmemory</strong></em>：建议必须设置，否则，将内存占满，造成服务器宕机</p>
<p>设置 redis 可以使用的内存量，一旦到达内存使用上限，redis 将会试图移除内部数据，移除规则可以通过 maxmemory-policy 来指定</p>
<p>如果 redis 无法根据移除规则来移除内存中的数据，或者设置了不允许移除，那么 redis 则会针对那些需要申请内存的指令返回错误信息，比如 SET、LPUSH 等</p>
<p>但是对于无内存申请的指令，仍然会正常响应，比如 GET 等。如果你的 redis 是主 redis（ 说明你的 redis 有从 redis ），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素</p>
<p><em><strong>maxmemory-policy</strong></em></p>
<p><em><strong>volatile-lru</strong></em>：使用 LRU 算法移除 key，只对设置了过期时间的键（最近最少使用）</p>
<p><em><strong>allkeys-lru</strong></em>：在所有集合 key 中，使用 LRU 算法移除 key</p>
<p><em><strong>volatile-random</strong></em>：在过期集合中移除随机的 key，只对设置了过期时间的键</p>
<p><em><strong>allkeys-random</strong></em>：在所有集合 key 中，移除随机的 key</p>
<p><em><strong>volatile-ttl</strong></em>：移除那些 TTL 值最小的 key，即那些最近要过期的 key</p>
<p><em><strong>noeviction</strong></em>：不进行移除。针对写操作，只是返回错误信息</p>
<p><em><strong>maxmemory-samples</strong></em>：设置样本数量，<em><strong>LRU</strong></em> 算法和最小 <em><strong>TTL</strong></em> 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，<em><strong>redis</strong></em> 默认会检查这么多个 <em><strong>key</strong></em> 并选择其中 <em><strong>LRU</strong></em> 的那个</p>
<p>一般设置 3 到 7 的数字，数值越小样本越不准确，但性能消耗越小</p>
<h2 id="常用五大基本数据类型"><a href="#常用五大基本数据类型" class="headerlink" title="常用五大基本数据类型"></a>常用五大基本数据类型</h2><h3 id="key操作"><a href="#key操作" class="headerlink" title="key操作"></a>key操作</h3><p><code>keys *</code>：查看当前库所有 <em><strong>key</strong></em></p>
<p><code>exists key</code>：判断某个 <em><strong>key</strong></em> 是否存在</p>
<p><code>type key</code>：查看你的 <em><strong>key</strong></em> 是什么类型</p>
<p><code>del key</code> ：删除指定的 <em><strong>key</strong></em> 数据</p>
<p><code>unlink key</code>：根据 <em><strong>value</strong></em> 选择非阻塞删除，仅将 <em><strong>keys</strong></em> 从 <em><strong>keyspace</strong></em> 元数据中删除，真正的删除在后续异步操作</p>
<p><code>expire key n</code> ：为给定的 <em><strong>key</strong></em> 设置过期时间</p>
<p><code>ttl key</code>：查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>
<p><code>select</code>：切换数据库（数据库有0~15，0是默认的数据库）</p>
<p><code>dbsize</code>：查看当前数据库中 <em><strong>key</strong></em> 的数量</p>
<p><code>flushdb</code>：清空当前库</p>
<p><code>flushall</code>：清空全部库</p>
<h3 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h3><p><em><strong>String</strong></em> 类型是二进制安全的，可以包含任何数据，比如 <em><strong>jpg</strong></em> 图片或者序列化的对象</p>
<p><em><strong>String</strong></em> 类型是 <em><strong>Redis</strong></em> 最基本的数据类型，一个 <em><strong>Redis</strong></em> 中字符串 <em><strong>value</strong></em> 最多可以是 512M</p>
<p>常用命令：</p>
<p><code>set &lt;key&gt;&lt;value&gt;</code>：添加键值对（若key已经存在则修改value的值）</p>
<p><code>get &lt;key&gt;</code>：查询对应键的值</p>
<p><code>append &lt;key&gt;&lt;value&gt;</code>：将给定的 value 追加到原值的末尾</p>
<p><code>strlen &lt;key&gt;</code>：获得值的长度</p>
<p><code>setnx &lt;key&gt;&lt;value&gt;</code>：只有在 <em><strong>key</strong></em> 不存在时，设置 <em><strong>key</strong></em> 的值</p>
<p><code>incr &lt;key&gt;</code>：将 <em><strong>key</strong></em> 中储存的数字值增 1，只能对数字值操作，如果为空，新增值为 1（<strong>具有原子性</strong>）</p>
<p><code>decr &lt;key&gt;</code>：将 <em><strong>key</strong></em> 中储存的数字值减 1，只能对数字值操作，如果为空，新增值为 -1</p>
<p><code>incrby/decrby &lt;key&gt;&lt;步长&gt;</code>：将 <em><strong>key</strong></em> 中储存的数字值增减，自定义步长</p>
<p><code>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;...</code> ：同时设置一个或多个 <em><strong>key-value</strong></em> 对</p>
<p><code>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt;...</code>：同时获取一个或多个 <em><strong>value</strong></em></p>
<p><code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; </code>：同时设置一个或多个 <em><strong>key-value</strong></em> 对（所有给定 <em><strong>key</strong></em> 都不存在）</p>
<p><code>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code>：获得值中此范围的数据，从0开始</p>
<p><code>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code>：在起始位置后插入value的值</p>
<p><code>setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code>：设置键值的同时，设置过期时间，单位秒</p>
<p><code>getset &lt;key&gt;&lt;value&gt;</code>：以新换旧，设置了新值同时获得旧值。</p>
<p><strong>原子性</strong></p>
<p>所谓 <strong>原子</strong> 操作是指不会被线程调度机制打断的操作，操作一旦开始，就一直运行到结束，中间不会有任何 <em><strong>context switch</strong></em> （切换到另一个线程）</p>
<ul>
<li>在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间</li>
<li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作</li>
</ul>
<p><em><strong>Redis</strong></em> 单命令的原子性主要得益于 <em><strong>Redis</strong></em> 的单线程</p>
<p><strong>数据结构</strong></p>
<p>String内部结构实现上类似于 <em><strong>Java</strong></em> 的 <em><strong>ArrayList</strong></em>，采用预分配冗余空间的方式来减少内存的频繁分配</p>
<h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><p><em><strong>Redis</strong></em> 列表是简单的字符串列表，按照插入顺序排序，可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>底层实际是个双向链表，对两端的操作性能很高，通过索引下标操作中间的节点性能会较差</p>
<p>常用命令：</p>
<p><code>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ...</code>： 从左边&#x2F;右边插入一个或多个值</p>
<p><code>lpop/rpop &lt;key&gt;</code>：从左边&#x2F;右边吐出一个值。值在键在，值光键亡</p>
<p><code>rpoplpush &lt;key1&gt;&lt;key2&gt;</code>：从 <em><strong>key1</strong></em> 列表右边吐出一个值，插到 <em><strong>key2</strong></em> 列表左边</p>
<p><code>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code>：按照索引下标获得元素（从左到右），0左边第一个，-1右边第一个，（0 -1表示获取所有）</p>
<p><code>lindex &lt;key&gt;&lt;index&gt;</code>：按照索引下标获得元素（从左到右）</p>
<p><code>llen &lt;key&gt;</code>：获得列表长度</p>
<p><code>linsert &lt;key&gt; before/after &lt;value&gt;&lt;newvalue&gt;</code>：在 <em><strong>value</strong></em> 的前面&#x2F;后面插入 <em><strong>newvalue</strong></em> 插入值</p>
<p><code>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</code>：从左边删除 <em><strong>n</strong></em> 个 <em><strong>value</strong></em>值（从左到右）</p>
<p><code>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;</code>：将列表 <em><strong>key</strong></em> 下标为 <em><strong>index</strong></em> 的值替换成 <em><strong>value</strong></em></p>
<p><strong>数据结构</strong></p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <em><strong>ziplist</strong></em>，也即是压缩列表</p>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存，当数据量比较多的时候才会改成 <em><strong>quicklist</strong></em></p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间，<em><strong>Redis</strong></em> 将链表和 <em><strong>ziplist</strong></em> 结合起来组成了 <em><strong>quicklist</strong></em>。也就是将多个 <em><strong>ziplist</strong></em> 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余</p>
<h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p><em><strong>Set</strong></em> 对外提供的功能与 <em><strong>List</strong></em> 类似列表的功能，特殊之处在于 <em><strong>Set</strong></em> 是可以 <strong>自动排重</strong> 的，并且 <em><strong>Set</strong></em> 提供了判断某个成员是否在一个 <em><strong>Set</strong></em> 集合内的重要接口</p>
<p><em><strong>Redis</strong></em> 的 <em><strong>Set</strong></em> 是 <em><strong>String</strong></em> 类型的无序集合，底层其实是一个 <em><strong>value</strong></em> 为 <em><strong>null</strong></em> 的 <em><strong>hash</strong></em> 表，所以添加，删除，查找的复杂度都是 <em><strong>O(1)</strong></em></p>
<p>常用命令：</p>
<p><code>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ... </code>：将一个或多个 <em><strong>member</strong></em> 元素加入到集合 <em><strong>key</strong></em> 中，已经存在的 <em><strong>member</strong></em> 元素将被忽略</p>
<p><code>smembers &lt;key&gt;</code>：取出该集合的所有值</p>
<p><code>sismember &lt;key&gt;&lt;value&gt;</code>：判断集合 <em><strong>key</strong></em> 是否为含有该 <em><strong>value</strong></em> 值，有返回 1，没有返回 0</p>
<p><code>scard &lt;key&gt;</code>：返回该集合的元素个数</p>
<p><code>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ...</code>：删除集合中的某个元素</p>
<p><code>spop &lt;key&gt;</code>：随机从该集合中吐出一个值，值光键亡</p>
<p><code>srandmember &lt;key&gt;&lt;n&gt;</code>：随机从该集合中取出 <em><strong>n</strong></em> 个值，不会从集合中删除</p>
<p><code>smove &lt;key&gt;&lt;newkey&gt;&lt;value&gt;</code>：把集合中一个值从一个集合(key)移动到另一个集合(newkey)</p>
<p><code>sinter &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的交集元素</p>
<p><code>sunion &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的并集元素</p>
<p><code>sdiff &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的差集元素（<em><strong>key1</strong></em> 中的，不包含 <em><strong>key2</strong></em> 中的）</p>
<p><strong>数据结构</strong></p>
<p><em><strong>Set</strong></em> 数据结构是字典，字典是用哈希表实现的</p>
<h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p><em><strong>Redis hash</strong></em> 是一个键值对集合</p>
<p><em><strong>Redis hash</strong></em> 是一个 <em><strong>String</strong></em> 类型的 <em><strong>field</strong></em> 和 <em><strong>value</strong></em> 的映射表，<em><strong>hash</strong></em> 特别适合用于存储对象</p>
<p>常用命令：</p>
<p><code>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：给 <em><strong>key</strong></em> 集合中的 <em><strong>field</strong></em> 键赋值 <em><strong>value</strong></em></p>
<p><code>hget &lt;key1&gt;&lt;field&gt;</code>：从 <em><strong>key1</strong></em> 集合 <em><strong>field</strong></em> 取出 <em><strong>value</strong></em></p>
<p><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...</code>： 批量设置 <em><strong>hash</strong></em> 的值</p>
<p><code>hexists &lt;key1&gt;&lt;field&gt;</code>：查看哈希表 <em><strong>key</strong></em> 中，给定域 <em><strong>field</strong></em> 是否存在</p>
<p><code>hkeys &lt;key&gt;</code>：列出该 <em><strong>hash</strong></em> 集合的所有 <em><strong>field</strong></em></p>
<p><code>hvals &lt;key&gt;</code>：列出该 <em><strong>hash</strong></em> 集合的所有 <em><strong>value</strong></em></p>
<p><code>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;</code>：为哈希表 <em><strong>key</strong></em> 中的域 <em><strong>field</strong></em> 的值加上增量 1   -1</p>
<p><code>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：将哈希表 <em><strong>key</strong></em> 中的域 <em><strong>field</strong></em> 的值设置为 <em><strong>value</strong></em>（当域 <em><strong>field</strong></em> 不存在）</p>
<p><strong>数据结构</strong></p>
<p><em><strong>Hash</strong></em> 类型对应的数据结构是两种：<em><strong>ziplist</strong></em>（压缩列表），<em><strong>hashtable</strong></em>（哈希表）</p>
<p>当 <em><strong>field-value</strong></em> 长度较短且个数较少时，使用 <em><strong>ziplist</strong></em>，否则使用 <em><strong>hashtable</strong></em></p>
<h3 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h3><p>有序集合的每个成员都关联了一个评分（<em><strong>score</strong></em>），这个评分（<em><strong>score</strong></em>）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复的</p>
<p>因为元素是有序的，所以可以很快的根据评分（<em><strong>score</strong></em>）或者次序（<em><strong>position</strong></em>）来获取一个范围的元素</p>
<p>常用命令：</p>
<p><code>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;...</code>：将一个或多个 <em><strong>member</strong></em> 元素及其 <em><strong>score</strong></em> 值加入到有序集 <em><strong>key</strong></em> 当中</p>
<p><code>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES] </code>：返回有序集 <em><strong>key</strong></em> 中，下标在 <em><strong>start和stop</strong></em> 之间的元素</p>
<p>当带 <em><strong>WITHSCORES</strong></em>，可以让分数一起和值返回到结果集</p>
<p><code>zrangebyscore &lt;key&gt; min max [withscores] [limit offset count]</code>：返回有序集 <em><strong>key</strong></em> 中，所有 <em><strong>score</strong></em> 值介于 <em><strong>min</strong></em> 和 <em><strong>max</strong></em> 之间（包括等于 <em><strong>min</strong></em> 或 <em><strong>max</strong></em> ）的成员，有序集成员按 <em><strong>score</strong></em> 值递增（从小到大）排列</p>
<p><code>zrevrangebyscore &lt;key&gt; max min [withscores] [limit offset count] </code>：同上，改为从大到小排列</p>
<p><code>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;</code>：为元素的 <em><strong>score</strong></em> 加上增量</p>
<p><code>zrem &lt;key&gt;&lt;value&gt;</code>：删除该集合下，指定值的元素</p>
<p><code>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;</code>：统计该集合，分数区间内的元素个数</p>
<p><code>zrank &lt;key&gt;&lt;value&gt;</code>：返回该值在集合中的排名，从 0 开始</p>
<p><strong>数据结构</strong></p>
<p><em><strong>SortedSet（zset）</strong></em>是 <em><strong>Redis</strong></em> 等价于 <em><strong>Java</strong></em> 的数据结构 ***Map&lt;String, Double&gt;***，可以给每一个元素 <em><strong>value</strong></em> 赋予一个权重 <em><strong>score</strong></em>，并且它又类似于 <em><strong>TreeSet</strong></em>，内部的元素会按照权重 <em><strong>score</strong></em> 进行排序，可以得到每个元素的名次，还可以通过 <em><strong>score</strong></em> 的范围来获取元素的列表</p>
<p><em><strong>zset</strong></em> 底层使用了两个数据结构</p>
<ul>
<li><em><strong>hash</strong></em>，<em><strong>hash</strong></em> 的作用就是关联元素 <em><strong>value</strong></em> 和权重 <em><strong>score</strong></em>，保障元素 <em><strong>value</strong></em> 的唯一性，可以通过元素 <em><strong>value</strong></em> 找到相应的 <em><strong>score</strong></em> 值</li>
<li>跳跃表，跳跃表的目的在于给元素 <em><strong>value</strong></em> 排序，根据 <em><strong>score</strong></em> 的范围获取元素列表</li>
</ul>
<h2 id="Redis6新数据结构"><a href="#Redis6新数据结构" class="headerlink" title="Redis6新数据结构"></a>Redis6新数据结构</h2><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>实际是字符串类型（key-value），但是可以对字符串的位进行操作，可以将value看做数组（将字符串使用二进制0和1表示，数组的每一个元素称为偏移量）</p>
<p>常用命令：</p>
<p><code>setbit &lt;key&gt;&lt;offset&gt;&lt;value&gt;</code>：设置Bitmaps中某个偏移量的值（0或1）</p>
<p><code>get &lt;key&gt;&lt;offset&gt;</code>：获取Bitmaps中某个偏移量的值</p>
<p><code>bitcount &lt;key&gt; [start end]</code>：统计字符串从start到end字节比特值是1的数量</p>
<p><code>bitop and(or/not/xor) &lt;destkey&gt; &lt;key&gt;&lt;key1&gt;...</code>：多个Bitmaps的交集，并集，非，异或操作，并将结果保存在destkey中</p>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>用来做基数统计的（基数：集合中去除重复元素之后所得的集合中元素的个数）</p>
<p>常用命令：</p>
<p><code>pfadd &lt;key&gt;&lt;element&gt;&lt;element1&gt;...</code>：添加指定元素到HyperLogLog中</p>
<p><code>pfcount &lt;key&gt;&lt;key1&gt;...</code>：统计HLL的近似基数</p>
<p><code>pfmerge &lt;destkey&gt;&lt;sourvekey&gt;&lt;sourvekey1&gt;...</code>：将一个或多个HLL合并之后的结果存储在另一个HLL中</p>
<h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><p>元素的2维坐标，在地图上就是经度和纬度</p>
<p>常见命令：</p>
<p><code>geoadd &lt;key&gt;&lt;longitude&gt;&lt;latitude&gt;&lt;member&gt;&lt;longitude1&gt;&lt;latitude1&gt;&lt;member1&gt;...</code>：添加地理位置（经度-180<del>180，纬度-85.05</del>85.05，名称）</p>
<p><code>geopos &lt;key&gt;&lt;member&gt;&lt;member1&gt;...</code>：获得指定地区的坐标信息</p>
<p><code>geodist &lt;key&gt;&lt;member1&gt;&lt;member2&gt; [m|km|mi|ft]</code>：获取两个位置之间的直线距离（米（默认），千米，英里，英尺）</p>
<p><code>georadius &lt;key&gt;&lt;longitude&gt;&lt;latitude&gt;&lt;radius&gt; [m|km|mi|ft]</code>：以给定的经纬度为中心，找出某一半径内的元素</p>
<h2 id="Redis的发布与订阅"><a href="#Redis的发布与订阅" class="headerlink" title="Redis的发布与订阅"></a>Redis的发布与订阅</h2><p>Redis 发布订阅（ <em><strong>pub&#x2F;sub</strong></em> ）是一种消息通信模式：发送者（ <em><strong>pub</strong></em> ）发送消息，订阅者（ <em><strong>sub</strong></em> ）接收消息</p>
<p>Redis 客户端可以订阅任意数量的频道</p>
<p>客户端可以订阅频道</p>
<img src="Redis/image-20220402231459951.png" srcset="/img/loading.gif" lazyload alt="image-20220402231459951" style="zoom:80%;" />

<p>当给这个频道发布消息后，消息就会发送给订阅的客户端</p>
<img src="Redis/image-20220402231509749.png" srcset="/img/loading.gif" lazyload alt="image-20220402231509749" style="zoom:80%;" />

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">subscribe channel  <span class="hljs-comment">#订阅channel频道</span><br>publish channel hello  <span class="hljs-comment">#频道发送hello信息</span><br></code></pre></td></tr></table></figure>



<h2 id="事务和锁机制"><a href="#事务和锁机制" class="headerlink" title="事务和锁机制"></a>事务和锁机制</h2><p>Redis 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</p>
<p>Redis 事务的主要作用就是<strong>串联多个命令</strong>防止别的命令插队</p>
<p><img src="Redis/image-20220402231519830.png" srcset="/img/loading.gif" lazyload alt="image-20220402231519830" style="zoom:80%;" /><img src="/Redis/image-20220402231537723.png" srcset="/img/loading.gif" lazyload alt="image-20220402231537723"></p>
<p>从输入 <em><strong>Multi</strong></em> 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 <em><strong>Exec</strong></em> 后，<em><strong>Redis</strong></em> 会将之前的命令队列中的命令依次执行（组队的过程中可以通过 <em><strong>Discard</strong></em> 来放弃组队）</p>
<p>当组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消；执行时某个命令出现了错误报告，只是出错的命令不被执行，其他命令正常执行</p>
<ul>
<li><p>组队成功，提交成功</p>
<img src="Redis/image-20220402231541245.png" srcset="/img/loading.gif" lazyload alt="image-20220402231541245" style="zoom:80%;" />
</li>
<li><p>放弃组队</p>
<img src="Redis/image-20220402231550506.png" srcset="/img/loading.gif" lazyload alt="image-20220402231550506" style="zoom:80%;" /></li>
</ul>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁（<em><strong>Pessimistic Lock</strong></em>），即每次去拿数据的时候都认为有其他线程会修改，所以每次在拿数据的时候都会上锁，这样其他线程想要拿到这个数据就会被 <em><strong>block</strong></em> 直到成功拿到锁（效率低）</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁（<em><strong>Optimistic Lock</strong></em>），即每次去拿数据的时候都认为其他线程不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间有没有其他线程去更新这个数据，可以使用版本号等机制（更新数据时版本号同样更新）</p>
<p><strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong></p>
<p>Redis就是利用 <em><strong>check-and-set</strong></em> （判断版本号是否相同）机制实现事务的</p>
<h4 id="Watch命令、unwatch命令"><a href="#Watch命令、unwatch命令" class="headerlink" title="Watch命令、unwatch命令"></a>Watch命令、unwatch命令</h4><p><strong>可以解决超卖的问题，但会造成库存遗留问题</strong></p>
<p><code>unwatch</code>：取消 <em><strong>WATCH</strong></em> 命令对所有 <em><strong>key</strong></em> 的监视，如果在执行 <em><strong>WATCH</strong></em> 命令之后，<em><strong>EXEC</strong></em> 命令或 <em><strong>DISCARD</strong></em> 命令先被执行，那么就不需要再执行 <em><strong>UNWATCH</strong></em></p>
<h3 id="事务三特性"><a href="#事务三特性" class="headerlink" title="事务三特性"></a>事务三特性</h3><ul>
<li><p>单独的隔离操作</p>
<p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</p>
</li>
<li><p>没有隔离级别的概念</p>
<p>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</p>
</li>
<li><p>不保证原子性</p>
<p>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</p>
</li>
</ul>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 即 <em><strong>Snapshot</strong></em> 快照，恢复时是将快照文件直接读到内存里</p>
<img src="Redis/image-20220402231605922.png" srcset="/img/loading.gif" lazyload alt="image-20220402231605922" style="zoom:80%;" />

<p>Redis会单独创建一个子进程（<em><strong>fork</strong></em>）来进行持久化</p>
<p>先将数据写入到一个临时文件中，待持久化过程完成后，再将这个临时文件内容覆盖到 <em><strong>dump.rdb</strong></em></p>
<p>整个过程中，主进程是不进行任何 <em><strong>IO</strong></em> 操作的，这就确保了极高的性能，如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 <em><strong>RDB</strong></em> 方式要比 <em><strong>AOF</strong></em> 方式更加的高效</p>
<p><strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong></p>
<h4 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h4><ul>
<li>作用是复制一个与当前进程一样的进程，新进程的所有数据（变量、环境变量、程序计数器等） 都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</li>
<li>在Linux程序中，<em><strong>fork()</strong></em> 会产生一个和父进程完全相同的子进程，但子进程在此后多会 <em><strong>exec</strong></em> 系统调用，出于效率考虑，Linux中引入了 <strong>写时拷贝技术</strong></li>
<li><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</li>
</ul>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><strong>dump.rdb</strong>：文件名字，在 <em><strong>redis.conf</strong></em> 中配置文件名称，默认为 <em><strong>dump.rdb</strong></em></p>
<p><strong>dump.rdb</strong>：保存位置，<em><strong>rdb</strong></em> 文件的保存路径可以修改，默认为 <em><strong>Redis</strong></em> 启动时命令行所在的目录下</p>
<p><em><strong>stop-writes-on-bgsave-error</strong></em>：当 <em><strong>redis</strong></em> 无法写入磁盘，关闭 <em><strong>redis</strong></em> 的写入操作</p>
<p><em><strong>rdbcompression</strong></em>：持久化的文件是否进行压缩存储</p>
<p><em><strong>rdbchecksum</strong></em>：完整性的检查，即数据是否完整性、准确性</p>
<p><em><strong>save</strong></em>：表示写操作的次数（格式：save 秒 写操作次数，代表在该秒数内进行多少次写操作会将数据写入磁盘）</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高更适合使用</li>
<li>节省磁盘空间</li>
<li>恢复速度快</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><em><strong>Fork</strong></em> 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑</li>
<li>虽然Redis在 <em><strong>fork</strong></em> 时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能</li>
<li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外 <em><strong>down</strong></em> 掉，就会丢失最后一次快照后的所有修改</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>以日志的形式来记录每个写操作（增量保存），将 Redis 执行过的所有写指令记录下来（读操作不记录）， 只许追加文件不可以修改文件，如果 Redis 重启就会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<p><strong>执行流程</strong></p>
<ul>
<li>客户端的请求写命令会被 <em><strong>append</strong></em> 追加到 <em><strong>AOF</strong></em> 缓冲区内</li>
<li><em><strong>AOF</strong></em> 缓冲区根据 <em><strong>AOF</strong></em> 持久化策略 <code>[always,everysec,no]</code> 将操作 <em><strong>sync</strong></em> 同步到磁盘的 <em><strong>AOF</strong></em> 文件中</li>
<li><em><strong>AOF</strong></em> 文件大小超过重写策略或手动重写时，会对 <em><strong>AOF</strong></em> 文件 <em><strong>Rewrite</strong></em> 重写，压缩 <em><strong>AOF</strong></em> 文件容量</li>
<li><em><strong>Redis</strong></em> 服务重启时，会重新 <em><strong>load</strong></em> 加载 <em><strong>AOF</strong></em> 文件中的写操作达到数据恢复的目的</li>
</ul>
<p><em><strong>AOF</strong></em> 和 <em><strong>RDB</strong></em> 同时开启时，系统默认读取 <em><strong>AOF</strong></em> 的数据（数据不会存在丢失）</p>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p><strong>AOF默认不开启</strong></p>
<p><strong>appendonly.aof</strong>：文件名字，保存路径容rdb一致</p>
<p><em><strong>appendfsync always</strong></em>：始终同步，每次 <em><strong>Redis</strong></em> 的写入都会立刻记入日志（性能较差但数据完整性比较好）</p>
<p><em><strong>appendfsync everysec</strong></em>：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失</p>
<p><em><strong>appendfsync no</strong></em>：Redis 不主动进行同步，把同步时机交给操作系统</p>
<p><strong>Rewrite压缩</strong></p>
<p>当 <em><strong>AOF</strong></em> 文件的大小超过所设定的阈值时，Redis 就会启动 <em><strong>AOF</strong></em> 文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令 <em><strong>bgrewriteaof</strong></em></p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>备份机制更稳健，丢失数据概率更低</li>
<li>可读的日志文本，通过操作 <em><strong>AOF</strong></em> 稳健，可以处理误操作</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>比起 <em><strong>RDB</strong></em> 占用更多的磁盘空间</li>
<li>恢复备份速度要慢</li>
<li>每次读写都同步的话，有一定的性能压力</li>
<li>存在个别 <em><strong>Bug</strong></em>，造成不能恢复</li>
</ul>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>官方推荐两个都启用</p>
<p>如果对数据不敏感，可以选单独用 <em><strong>RDB</strong></em></p>
<p>不建议单独用 <em><strong>AOF</strong></em>，因为可能会出现 <em><strong>Bug</strong></em></p>
<p>如果只是做纯内存缓存，可以都不用</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主机数据更新后根据配置和策略， 自动同步到从机的 <em><strong>master&#x2F;slaver</strong></em> 机制，<em><strong>Master</strong></em> 以写为主，<em><strong>Slaver</strong></em> 以读为主</p>
<img src="Redis/image-20220402231618214.png" srcset="/img/loading.gif" lazyload alt="image-20220402231618214" style="zoom:80%;" />

<ol>
<li>读写分离，性能扩展</li>
<li>容灾快速恢复</li>
<li>一主多从</li>
</ol>
<h3 id="搭建一主两从"><a href="#搭建一主两从" class="headerlink" title="搭建一主两从"></a>搭建一主两从</h3><p>将 <em><strong>redis.conf</strong></em> 复制到当前目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> /etc/redis.conf /opt/etc/<br></code></pre></td></tr></table></figure>

<p>创建 3 个 <em><strong>redis.conf</strong></em> 配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis6379.conf<br><br><span class="hljs-comment"># redis6379.conf</span><br>include /opt/etc/redis.conf <span class="hljs-comment">#引入原来的redis配置文件</span><br>pidfile /var/run/redis_6379.pid<br>port 6379<br>dbfilename dump6379.rdb<br></code></pre></td></tr></table></figure>

<p>启动 3 台 <em><strong>redis</strong></em> 服务器，并查看主机运行情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs baash">redis-server /etc/redis6379.conf<br>redis-cli -p 6379<br><br>info replication<br></code></pre></td></tr></table></figure>

<p>配从不配主</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">slaveof  &lt;ip&gt;&lt;port&gt;   <span class="hljs-comment">#成为某个实例的从服务器</span><br></code></pre></td></tr></table></figure>



<h3 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h3><p>一个主机，两个从机</p>
<p>当从机宕机，重新启动后不在是从机（重新设置为从机后会把主机的数据重新复制）</p>
<p>当主机宕机，从机仍然保持是从机，重新启动后仍然是主机</p>
<h3 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h3><img src="Redis/image-20220402231627461.png" srcset="/img/loading.gif" lazyload alt="image-20220402231627461" style="zoom:80%;" />

<p>上一个 <em><strong>slave</strong></em> 可以是下一个 <em><strong>slave</strong></em> 的 <em><strong>master</strong></em>，<em><strong>slave</strong></em> 同样可以接收其他 <em><strong>slave</strong></em>的连接和同步请求，那么该 <em><strong>slave</strong></em> 作为了链条中下一个的 <em><strong>master</strong></em>，可以有效减轻 <em><strong>master</strong></em> 的写压力，去中心化降低风险</p>
<p>中途变更转向：会清除之前的数据，重新建立拷贝最新的</p>
<p>当某个 <em><strong>slave</strong></em> 宕机，后面的 <em><strong>slave</strong></em> 都没法备份</p>
<h3 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h3><p>当一个 <em><strong>master</strong></em> 宕机后，后面的 <em><strong>slave</strong></em> 可以立刻升为 <em><strong>master</strong></em>，其后面的 <em><strong>slave</strong></em> 不用做任何修改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">slaveof no one<br></code></pre></td></tr></table></figure>



<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p><strong>反客为主的自动版</strong>，即能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p>
<p>创建 <em><strong>sentinel.conf</strong></em> 文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> /opt/etc/sentinel.conf<br></code></pre></td></tr></table></figure>

<p>配置哨兵</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># mymaster：监控对象起的服务器名称</span><br><span class="hljs-comment"># 1表示至少有1个哨兵同意迁移的数量</span><br>sentinel monitor mymaster ip 端口号 1<br></code></pre></td></tr></table></figure>

<p>启动哨兵</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-sentinel  /opt/etc/sentinel.conf <br></code></pre></td></tr></table></figure>

<p>主机宕机，会从机选举中产生新的主机（宕机的主机重新启动后会变为从机）</p>
<p><strong>选举规则</strong></p>
<ul>
<li>根据优先级别<em><strong>slave-priority&#x2F;replica-priority</strong></em>，优先选择优先级靠前的</li>
<li>根据偏移量（从机和主机的数据一致性），优先选择偏移量大的</li>
<li>根据 <em><strong>runid</strong></em>（redis启动时会动生成的id），优先选择最小的服务</li>
</ul>
<h4 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h4><p>由于所有的写操作都是先在 <em><strong>master</strong></em> 上操作，然后同步更新到 <em><strong>slave</strong></em> 上，所以从 <em><strong>master</strong></em> 同步到 <em><strong>slave</strong></em> 有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，<em><strong>slave</strong></em> 机器数量的增加也会使这个问题更加严重</p>
<h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><ul>
<li><em><strong>slave</strong></em> 启动成功连接到 <em><strong>master</strong></em> 后会发送一个 <em><strong>sync</strong></em> 命令（同步命令）</li>
<li><em><strong>master</strong></em> 接到命令启动后台的存盘进程，对数据进行持久化操作，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<em><strong>master</strong></em> 将传送整个数据文件（<em><strong>rdb</strong></em>）到 <em><strong>slave</strong></em>，以完成一次完全同步</li>
<li>连接成功之后当主服务进行写操作后，和从服务器进行数据同步</li>
<li>全量复制：<em><strong>slave</strong></em> 服务在接收到数据库文件数据后，将其存盘并加载到内存中</li>
<li>增量复制：<em><strong>master</strong></em> 继续将新的所有收集到的修改命令依次传给 <em><strong>slave</strong></em>，完成同步</li>
<li><em><strong>slave</strong></em>连接 <em><strong>master</strong></em>，一次完全同步（全量复制）将被自动执行</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>解决容量不够和并发写操作问题</p>
<ul>
<li><p>代理主机（ <em><strong>之前</strong></em> ）</p>
<img src="Redis/image-20220402231639618.png" srcset="/img/loading.gif" lazyload alt="image-20220402231639618" style="zoom:80%;" />
</li>
<li><p>无中心化集群配置（ <em><strong>redis3.0</strong></em> ）</p>
</li>
</ul>
<img src="Redis/image-20220402231651540.png" srcset="/img/loading.gif" lazyload alt="image-20220402231651540" style="zoom:80%;" />

<p>Redis 集群实现了对 Redis 的水平扩容，即启动 <em><strong>N</strong></em> 个 Redis 节点，将整个数据库分布存储在这 <em><strong>N</strong></em> 个节点中，每个节点存储总数据的 <em><strong>1&#x2F;N</strong></em> </p>
<p>Redis 集群通过分区（<em><strong>partition</strong></em>）来提供一定程度的可用性（<em><strong>availability</strong></em>），即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求</p>
<h3 id="搭建-Redis-集群"><a href="#搭建-Redis-集群" class="headerlink" title="搭建 Redis 集群"></a>搭建 <em>Redis</em> 集群</h3><p>创建配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">include /opt/etc/redis.conf <span class="hljs-comment">#引入原来的redis配置文件</span><br>pidfile /var/run/redis_6379.pid<br>port 6379<br>dbfilename dump6379.rdb<br>cluster-enabled <span class="hljs-built_in">yes</span>  <span class="hljs-comment">#打开集群模式</span><br>cluster-config-file nodes-6379.conf  <span class="hljs-comment">#设置节点配置文件名称，需要更改</span><br>cluster-node-timeout 15000  <span class="hljs-comment">#设置节点失联事件，超过该时间（ms），集群自动进行主从切换</span><br></code></pre></td></tr></table></figure>

<p>创建集群</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入redis安装目录</span><br><span class="hljs-built_in">cd</span> /opt/redis-6.2.6/src<br><br><span class="hljs-comment"># 执行  （--cluster-replicas 1，表示希望为集群中的每个主节点创建一个从节点）</span><br>redis-cli --cluster create --cluster-replicas 1 172.16.88.168:6379 172.16.88.168:6380 172.16.88.168:6381 172.16.88.168:6389 172.16.88.168:6390 172.16.88.168:6391<br></code></pre></td></tr></table></figure>

<p>采用集群策略连接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-cli -c -p 端口号  <span class="hljs-comment">#启动集群</span><br>cluster nodes  <span class="hljs-comment">#命令查看集群信息</span><br></code></pre></td></tr></table></figure>



<h4 id="集群分配"><a href="#集群分配" class="headerlink" title="集群分配"></a>集群分配</h4><p>一个集群至少要有三个主节点</p>
<p>分配原则尽量保证每个主数据库运行在不同的 <em><strong>IP</strong></em> 地址，每个从库和主库不在一个 <em><strong>IP</strong></em> 地址上</p>
<img src="Redis/image-20220402231700831.png" srcset="/img/loading.gif" lazyload alt="image-20220402231700831" style="zoom:80%;" />



<h4 id="什么是-slots"><a href="#什么是-slots" class="headerlink" title="什么是 slots"></a>什么是 slots</h4><p>一个Redis集群包含 <em><strong>16384</strong></em> 个插槽（<em><strong>hash slot</strong></em>），数据库中的每个键都属于这 <em><strong>16384</strong></em> 个插槽的其中一个</p>
<p>集群使用公式 <em><strong>CRC16(key)%16384</strong></em> 来计算键 <em><strong>key</strong></em> 属于哪个槽，<em><strong>CRC16(key)</strong></em> 语句用于计算键 <em><strong>key</strong></em> 的 <em><strong>CRC16</strong></em> 校验和 </p>
<p>集群中的每个节点负责处理一部分插槽</p>
<p> 例如， 如果一个集群有三个主库， 其中：</p>
<ul>
<li>节点 <em><strong>A</strong></em> 负责处理 <em><strong>0</strong></em> 号至 <em><strong>5460</strong></em> 号插槽</li>
<li>节点 <em><strong>B</strong></em> 负责处理 <em><strong>5461</strong></em> 号至 <em><strong>10922</strong></em> 号插槽</li>
<li>节点 <em><strong>C</strong></em> 负责处理 <em><strong>10923</strong></em> 号至 <em><strong>16383</strong></em> 号插槽</li>
</ul>
<h4 id="集群中录入值"><a href="#集群中录入值" class="headerlink" title="集群中录入值"></a>集群中录入值</h4><p>在 <em><strong>redis-cli</strong></em> 每次录入、查询键值，redis 都会计算出该 <em><strong>key</strong></em> 应该送往的插槽，如果不是该客户端对应服务器的插槽，redis 会报错，并告知应前往的redis实例地址和端口</p>
<p><em><strong>redis-cli</strong></em> 客户端提供了 <em><strong>–c</strong></em> 参数实现自动重定向</p>
<p>例如 <em><strong>redis-cli -c –p 6379</strong></em> 登入后，再录入、查询键值对可以自动重定向</p>
<p>集群中要一次添加多个<em><strong>key</strong></em>，需要将给<em><strong>key</strong></em>添加组（key后使用{user}，表示添加到user组）</p>
<h4 id="查询集群中的值"><a href="#查询集群中的值" class="headerlink" title="查询集群中的值"></a>查询集群中的值</h4><p>每个主机只能查询自己范围内的插槽的值</p>
<p><code>cluster keyslot &lt;key&gt;</code>：查询某个 <em><strong>key</strong></em> 的 **<em>slot</em> **</p>
<p><code>cluster countkeysinslot &lt;slot&gt;</code>：查询某个 <em><strong>slot</strong></em> 是否有值</p>
<p><code>CLUSTER GETKEYSINSLOT &lt;slot&gt;&lt;count&gt;</code>：返回 <em><strong>count</strong></em> 个 <em><strong>slot</strong></em> 槽中的键</p>
<h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><p>主节点下线，从节点会自动升为主节点（注意：<em><strong>15</strong></em> 秒超时），主节点恢复后会变成从机</p>
<p>如果所有某一段插槽的主从节点都宕掉，redis 服务是否还能继续</p>
<ul>
<li><em><strong>cluster-require-full-coverage&#x3D;yes</strong></em>：整个集群都挂掉</li>
<li><em><strong>cluster-require-full-coverage&#x3D;no</strong></em>：该插槽数据全都不能使用，也无法存储</li>
</ul>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>实现扩容</li>
<li>分摊压力</li>
<li>无中心配置相对简单</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>多键操作是不被支持的，需要给键分在同组，根据组给键分槽</li>
<li>多键的Redis事务和<em><strong>lua</strong></em> 脚本不被支持</li>
<li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至<em><strong>redis cluster</strong></em>，需要整体迁移而不是逐步过渡，复杂度较大</li>
</ul>
<h2 id="Jedis操作Redis"><a href="#Jedis操作Redis" class="headerlink" title="Jedis操作Redis"></a>Jedis操作Redis</h2><p><strong>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>连接 Redis</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.57.101&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pong</span> <span class="hljs-operator">=</span> jedis.ping();<br>        System.out.println(<span class="hljs-string">&quot;连接成功：&quot;</span> + pong);<br>        jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Key</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br>Set&lt;String&gt; keys = jedis.keys(<span class="hljs-string">&quot;*&quot;</span>);<br><span class="hljs-keyword">for</span> (String key : keys) &#123;<br> System.out.println(key);<br>&#125;<br>System.out.println(jedis.exists(<span class="hljs-string">&quot;k1&quot;</span>));<br>System.out.println(jedis.ttl(<span class="hljs-string">&quot;k1&quot;</span>));                <br>System.out.println(jedis.get(<span class="hljs-string">&quot;k1&quot;</span>));<br></code></pre></td></tr></table></figure>

<p><strong>String</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.mset(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;v1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;v2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>,<span class="hljs-string">&quot;v3&quot;</span>);<br>System.out.println(jedis.mget(<span class="hljs-string">&quot;str1&quot;</span>,<span class="hljs-string">&quot;str2&quot;</span>,<span class="hljs-string">&quot;str3&quot;</span>));<br></code></pre></td></tr></table></figure>

<p><strong>List</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = jedis.lrange(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (String element : list) &#123;<br> System.out.println(element);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Set</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.sadd(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order01&quot;</span>);<br>Set&lt;String&gt; smembers = jedis.smembers(<span class="hljs-string">&quot;orders&quot;</span>);<br><span class="hljs-keyword">for</span> (String order : smembers) &#123;<br> System.out.println(order);<br>&#125;<br>jedis.srem(<span class="hljs-string">&quot;orders&quot;</span>, <span class="hljs-string">&quot;order02&quot;</span>);<br></code></pre></td></tr></table></figure>

<p><strong>Hash</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.hset(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br>System.out.println(jedis.hget(<span class="hljs-string">&quot;hash1&quot;</span>,<span class="hljs-string">&quot;userName&quot;</span>));<br><br>Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,String&gt;();<br>map.put(<span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;13810169999&quot;</span>);<br>jedis.hmset(<span class="hljs-string">&quot;hash2&quot;</span>,map);<br>List&lt;String&gt; result = jedis.hmget(<span class="hljs-string">&quot;hash2&quot;</span>, <span class="hljs-string">&quot;telphone&quot;</span>,<span class="hljs-string">&quot;email&quot;</span>);<br><span class="hljs-keyword">for</span> (String element : result) &#123;<br> System.out.println(element);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>zset</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.zadd(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">100d</span>, <span class="hljs-string">&quot;z3&quot;</span>);<br>Set&lt;String&gt; zrange = jedis.zrange(<span class="hljs-string">&quot;zset01&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (String e : zrange) &#123;<br> System.out.println(e);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Jedis-主从复制"><a href="#Jedis-主从复制" class="headerlink" title="Jedis 主从复制"></a><em>Jedis</em> 主从复制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisSentinelPool jedisSentinelPool=<span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  Jedis <span class="hljs-title function_">getJedisFromSentinel</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-keyword">if</span>(jedisSentinelPool==<span class="hljs-literal">null</span>)&#123;<br>        Set&lt;String&gt; sentinelSet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        sentinelSet.add(<span class="hljs-string">&quot;172.16.88.168:26379&quot;</span>); <span class="hljs-comment">// 端口为sentinal</span><br>        <span class="hljs-comment">//创建自定义pool连接池类</span><br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">jedisPoolConfig</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        jedisPoolConfig.setMaxTotal(<span class="hljs-number">10</span>); <span class="hljs-comment">// 最大可用连接数</span><br>        jedisPoolConfig.setMaxIdle(<span class="hljs-number">5</span>); <span class="hljs-comment">// 最大闲置连接数</span><br>        jedisPoolConfig.setMinIdle(<span class="hljs-number">5</span>); <span class="hljs-comment">// 最小闲置连接数</span><br>        jedisPoolConfig.setBlockWhenExhausted(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 连接耗尽是否等待</span><br>        jedisPoolConfig.setMaxWaitMillis(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 等待时间</span><br>        jedisPoolConfig.setTestOnBorrow(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 取连接的时候进行测试</span><br><br>        jedisSentinelPool=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisSentinelPool</span>(<span class="hljs-string">&quot;mymaster&quot;</span>,sentinelSet,jedisPoolConfig); <span class="hljs-comment">// 服务主机名</span><br>        <span class="hljs-keyword">return</span> jedisSentinelPool.getResource();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> jedisSentinelPool.getResource();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="集群的-Jedis-开发"><a href="#集群的-Jedis-开发" class="headerlink" title="集群的 Jedis 开发"></a>集群的 <em>Jedis</em> 开发</h3><p>即使连接的不是主机，集群会自动切换主机存储（主机写，从机读）</p>
<p>无中心化主从集群，无论从哪台主机写的数据，其他主机上都能读到数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisClusterTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <br>        Set&lt;HostAndPort&gt;set =<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;HostAndPort&gt;();<br>        set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HostAndPort</span>(<span class="hljs-string">&quot;172.16.88.168&quot;</span>,<span class="hljs-number">6379</span>)); <span class="hljs-comment">// 任何一个端口</span><br>        <span class="hljs-comment">//创建集群</span><br>        <span class="hljs-type">JedisCluster</span> <span class="hljs-variable">jedisCluster</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisCluster</span>(set);<br>        jedisCluster.set(<span class="hljs-string">&quot;k1&quot;</span>, <span class="hljs-string">&quot;v1&quot;</span>);<br>        System.out.println(jedisCluster.get(<span class="hljs-string">&quot;k1&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="应用问题解决"><a href="#应用问题解决" class="headerlink" title="应用问题解决"></a>应用问题解决</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><img src="Redis/image-20220402231713881.png" srcset="/img/loading.gif" lazyload alt="image-20220402231713881" style="zoom: 80%;" />

<p><em><strong>key</strong></em> 对应的数据在数据源并不存在，每次针对此 <em><strong>key</strong></em> 的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源</p>
<p>比如用一个不存在的用户 <em><strong>id</strong></em> 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库</p>
<ol>
<li>应用服务器压力变大</li>
<li>redis 命中率下降，一直查询数据库</li>
</ol>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul>
<li><p><strong>对空值缓存</strong></p>
<p>如果一个查询返回的数据为空（不管是数据是否不存在），仍然把这个空结果（<em><strong>null</strong></em>）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</p>
</li>
<li><p><strong>设置可访问的名单（白名单）</strong></p>
<p>使用 <em><strong>bitmaps</strong></em> 类型定义一个可以访问的名单，名单 <em><strong>id</strong></em> 作为 <em><strong>bitmaps</strong></em> 的偏移量，每次访问和 <em><strong>bitmap</strong></em> 里面的 <em><strong>id</strong></em> 进行比较，如果访问 <em><strong>id</strong></em> 不在 <em><strong>bitmaps</strong></em> 里面，进行拦截，则不允许访问</p>
</li>
<li><p><strong>采用布隆过滤器</strong></p>
<p>布隆过滤器（<em><strong>Bloom Filter</strong></em>）是1970年由布隆提出的。它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）</p>
<p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难</p>
<p>将所有可能存在的数据哈希到一个足够大的 <em><strong>bitmaps</strong></em> 中，一个一定不存在的数据会被这个 <em><strong>bitmaps</strong></em> 拦截掉，从而避免了对底层存储系统的查询压力</p>
</li>
<li><p><strong>进行实时监控</strong></p>
<p>当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p>
</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><img src="Redis/image-20220402231733279.png" srcset="/img/loading.gif" lazyload alt="image-20220402231733279" style="zoom:80%;" />

<p><em><strong>key</strong></em> 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<em><strong>DB</strong></em> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <em><strong>DB</strong></em> 压垮</p>
<ol>
<li>数据库访问压力瞬间增大</li>
<li>redis中没有出现大量 <em><strong>key</strong></em> 过期，<em><strong>redis</strong></em> 正常运行（即某个经常访问的 <em><strong>key</strong></em> 过期，突然大量访问这个数据）</li>
</ol>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><ul>
<li><p><strong>预先设置热门数据</strong></p>
<p>在 redis 高峰访问之前，把一些热门数据提前存入到 redis 里面，加大这些热门数据 <em><strong>key</strong></em> 的时长</p>
</li>
<li><p><strong>实时调整</strong></p>
<p>现场监控哪些数据热门，实时调整 <em><strong>key</strong></em> 的过期时长</p>
</li>
<li><p><strong>使用锁</strong></p>
</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><em><strong>key</strong></em> 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<em><strong>DB</strong></em> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <em><strong>DB</strong></em> 压垮</p>
<p>缓存雪崩与缓存击穿的区别在于这里针对很多 <em><strong>key</strong></em> 缓存，前者则是某一个 <em><strong>key</strong></em></p>
<ol>
<li>数据库压力变大</li>
<li>即极少的时间段，查询大量 <em><strong>key</strong></em> 的集中过期情况</li>
</ol>
<h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><ul>
<li><p><strong>构建多级缓存架构</strong></p>
<p><em><strong>nginx</strong></em> 缓存 + <em><strong>redis</strong></em> 缓存 + 其他缓存（<em><strong>ehcache</strong></em>等）</p>
</li>
<li><p><strong>使用锁或队列</strong></p>
<p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况</p>
</li>
<li><p><strong>设置过期标志更新缓存</strong></p>
<p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 <em><strong>key</strong></em> 的缓存</p>
</li>
<li><p><strong>将缓存失效时间分散开</strong></p>
<p>比如我们可以在原有的失效时间基础上增加一个随机值，比如 1～5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件</p>
</li>
</ul>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3>
              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Redis</div>
      <div>http://example.com/2021/11/16/Redis/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Beitragsautor</div>
          <div>倔强的小强</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Veröffentlicht am</div>
          <div>2021年11月16日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Urheberrechtshinweis</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/11/16/JavaWeb/" title="JavaWeb">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JavaWeb</span>
                        <span class="visible-mobile">Vorheriger</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/13/Linux8/" title="Linux8">
                        <span class="hidden-mobile">Linux8</span>
                        <span class="visible-mobile">Nächster</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Inhaltsverzeichnis</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Suchen</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Stichwort</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog funktioniert am besten mit aktiviertem JavaScript</div>
  </noscript>
</body>
</html>
