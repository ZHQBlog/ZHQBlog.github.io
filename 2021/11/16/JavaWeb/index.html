

<!DOCTYPE html>
<html lang="zh_CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="倔强的小强">
  <meta name="keywords" content="倔强的小强">
  
    <meta name="description" content="Servlet，JSP，EL表达式，JSTL标签，Filter过滤器，JQuery框架，AJAX，JSON，MVC开发模式">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaWeb">
<meta property="og:url" content="http://example.com/2021/11/16/JavaWeb/index.html">
<meta property="og:site_name" content="小强的博客">
<meta property="og:description" content="Servlet，JSP，EL表达式，JSTL标签，Filter过滤器，JQuery框架，AJAX，JSON，MVC开发模式">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-11-16T11:03:57.000Z">
<meta property="article:modified_time" content="2022-03-17T14:12:11.398Z">
<meta property="article:author" content="倔强的小强">
<meta property="article:tag" content="倔强的小强">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>JavaWeb - 小强的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>❤</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Startseite
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archiv
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Kategorien
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Schlagwörter
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                Über
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JavaWeb"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-11-16 19:03" pubdate>
          2021年11月16日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k wörter
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          167 minuten
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JavaWeb</h1>
            
            <div class="markdown-body">
              
              <h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="Tomcat服务器"><a href="#Tomcat服务器" class="headerlink" title="Tomcat服务器"></a>Tomcat服务器</h2><p><strong>tomcat是实现了Servlet和JSP规范的容器</strong></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>bin：存放命令</p>
<p>conf：配置文件</p>
<p>lib：字节码库</p>
<p>logs：启动日志信息</p>
<p>temp：临时文件</p>
<p>webapps：项目存放目录</p>
<p>work：jsp相关目录，存放jsp文件翻译生成的文件</p>
<h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><p>webapps项目存放在该目录下，项目目录中文件结构如下</p>
<p>​	css</p>
<p>​	html</p>
<p>​	js</p>
<p>​	WEB-INF(规范，必须写) —–&gt; classes(字节码)    lib(jar包)     web.xml(配置文件)</p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Servlet是JavaEE规范之一，规范就是接口。</p>
<p>Servlet是运行在服务器上的Java小程序，它可以接收客户端发送过来的请求，并响应数据给客户端。</p>
<p>创建Servlet程序步骤：</p>
<ol>
<li>编写一个类实现Servlet接口</li>
<li>实现service()方法，处理请求，并响应数据</li>
<li>到web.xml中配置servlet程序的访问地址 或者 用@WebServlet(“虚拟路径”)</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 给Tomcat配置servlet程序--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 给servlet程序起一个别名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- servlet程序的全类名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.test.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 给servlet程序配置访问地址--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 告诉服务器，当前给HelloServlet程序配置地址--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置访问地址</span><br><span class="hljs-comment">		/代表：http://ip:端口/工程路径</span><br><span class="hljs-comment">	--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol>
<li>web容器会在容器上下文中寻找请求路径对应的Servlet对象<ol>
<li>若在请求路径中没找到对应的Servlet对象，会通过web.xml文件中的相关配置信息，得到请求路径对应的Servlet完整类名，再通过反射机制调用Servlet类的无参构造函数完成Servlet对象的实例化</li>
<li>若找到了就直接直接调用servlet对象</li>
</ol>
</li>
<li>执行init()初始化方法（init()方法在调用前已经创建好了）<strong>1,2步是在第一次访问创建Servlet程序时调用</strong></li>
<li>执行service()方法（每次访问都调用service()）</li>
<li>执行destroy()方法（在web工程停止时调用，对象没销毁之前调用destroy()方法进行对象销毁前最后的工作）</li>
</ol>
<p>注意：Servlet是单利模式，但构造方法不是私有的，多线程时存在安全问题，尽量不在Servlet中使用实例变量</p>
<h3 id="Servlet体系结构"><a href="#Servlet体系结构" class="headerlink" title="Servlet体系结构"></a>Servlet体系结构</h3><p>Servlet   ————–   接口</p>
<p>​	|    实现</p>
<p>GenericServlet    ————-   抽象类（将Servlet接口的其他方法进行了空实现，只将service()方法作为抽象方法）</p>
<p>​	|    继承</p>
<p>HttpServlet   ————–   抽象类（对http协议的一种封装，复写doGet和doPost方法就可，什么请求复写什么方法）</p>
<p>httpServlet是一个典型的模板方法设计模式</p>
<h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>每次只要有请求进入服务器，服务器都会创建一个Request对象，服务器就会把请求过来的Http协议信息解析封装到Request对象中，然后传递到service()方法中进行使用</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol>
<li><p>getContextPath()          获取虚拟目录，webapp的根路径</p>
</li>
<li><p>getRequestURI() 		 	   获得请求的资源路径</p>
</li>
<li><p>getRequestURL()	            获得请求的统一资源定位符（绝对路径）</p>
</li>
<li><p>getRemoteAdder()              获得客户端的ip地址</p>
</li>
<li><p>getServletPath()              获取servlet路径</p>
</li>
<li><p>getMethod()                      获得请求的方式（GET或POST）</p>
</li>
<li><p>getHeader(“User-Agent”)     获得消息报头</p>
</li>
<li><p>getParameter()                 获得请求参数值（在POST请求中有中文时要设置字符集 </p>
</li>
<li><p>getParameterValues()     获得请求参数值（多个值时使用）</p>
</li>
<li><p>getParameterNames()     获取所有请求参数名称，返回的是Enumeration类型</p>
</li>
<li><p>getParameterMap()          获取参数名称和值得Map集合</p>
</li>
<li><p>setAttribute(key, value)   设置域数据(request域:代表一次请求的范围,一般用于多个请求转发的资源共享)</p>
</li>
<li><p>getAttribute(key)               获取域数据</p>
</li>
<li><p>removeAttribute(key)        删除键值对</p>
</li>
<li><p>getReader()                       获取字符输入流，只能操作字符数据</p>
</li>
<li><p>getInputStream()              获取字节输入流，可以操作所有类型数据</p>
</li>
<li><p>getRequestDispatcher()获取请求转发对象           forward(req, rsep)进行转发</p>
<p>语法：</p>
<p>​		HttpServletRequest对象.getRequestDispatcher(“&#x2F;工程路径”).forward(HttpServletRequest对象1, 		HttpServletRequest对象2);</p>
<p>请求转发：服务器收到请求后，服务器内部从一个资源跳转到另一个资源的操作，一般服务器存在给另一个页面共享数据时使用</p>
<p>特点：浏览器地址栏不发生改变； 只能转发到当前服务器内部的资源； 转发是一次请求（可以使用request对象共享数据）</p>
</li>
</ol>
<h3 id="HttpServletResponse类"><a href="#HttpServletResponse类" class="headerlink" title="HttpServletResponse类"></a>HttpServletResponse类</h3><p>每次只要有请求进入Tomcat服务器，Tomcat服务器都会创建一个Response对象，表示请求过来的信息（所有相应的信息）</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><p>setHeader()：修改响应头信息</p>
<p>content-type：修改mime类型（mime类型就像这样的类型text&#x2F;html）</p>
<p>content-disposition：设置打开响应头的方式</p>
<p>输出流往客户端回传数据，两个流不能同时使用</p>
<p>getOutputStream()字节输出流——–常用于下载，传递二进制数据</p>
<p>getWriter()字符输出流————常用于回传字符串          </p>
<p>sendRedirect(“新地址”)：请求重定向</p>
<p>客户端给服务器发起请求，服务器给客户端一个新的地址，一般对数据库进行操作没有进行页面之间的数据共享时使用</p>
<p>特点：浏览器地址栏发生改变； 可以访问其他服务器的资源； 重定向是两次请求；可以解决页面刷新问题</p>
<h3 id="ServletContext类"><a href="#ServletContext类" class="headerlink" title="ServletContext类"></a>ServletContext类</h3><ol>
<li>ServletContext是一个接口，它代表整个web应用，可以和程序的服务器来通信</li>
<li>一个web工程，只有一个ServletContext对象实例，ServletContext对象是一个域对象</li>
<li>ServletContext是所有Servlet对象的四周环境代表，所有用户要想共享同一个数据时，可以把数据存放在ServletConfig的对象中，可以跨用户传递数据</li>
<li>获取方式：<ol>
<li>通过request对象获取：request.getServletContext()</li>
<li>通过HttpServlet获取：this.getServletContext()</li>
<li>通过ServletConfig获取：servletConfig.getServletContext()</li>
</ol>
</li>
<li>获取web.xml中配置的上下文参数context-param</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 上下文参数（属于整个web工程）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 上下文参数名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>namespace<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 上下文参数值--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol start="5">
<li><p>功能</p>
<ol>
<li><p>获取MIME类型：在互联网通信过程中定义的一种文件数据类型（大类型&#x2F;小类型）     例如：text&#x2F;html</p>
<p>String getMimeType(String file)</p>
</li>
<li><p>域对象：共享数据，整个web用户共享</p>
<p>setAttribute(key, value)   设置域数据          （域范围：整个web工程，所有用户的所有请求）</p>
<p>getAttribute(key)               获取域数据</p>
<p>removeAttribute(key)        删除键值对</p>
<p>getInitParamete(name)     获取上下文初始化参数</p>
</li>
<li><p>获取文件的真实（服务器）路径：</p>
<p>String getRealPath(String path)   path例如&#x2F;dao&#x2F;b.txt，其中&#x2F;表示webapp的根目录</p>
</li>
</ol>
</li>
</ol>
<h3 id="ServletConfig类"><a href="#ServletConfig类" class="headerlink" title="ServletConfig类"></a>ServletConfig类</h3><ol>
<li><p>ServletConfig是Servlet对象的配置信息类，Servlet配置信息在web.xml文件中，一个Servlet对象对应一个ServletConfig对象，Servlet程序创建时就创建对应的ServletConfig对象</p>
</li>
<li><p>常用方法</p>
<p>servletConfig.getServletName()：可以获取servlet程序的别名servlet-name的值</p>
<p>servletConfig.getInitParamete(name)：获取初始化参数init-param的值</p>
<p>servletConfig.getServletContext()：获取Servlet上下文对象</p>
</li>
<li><p>将init方法的ServletConfig参数在service方法中使用时，创建一个私有实例变量ServletConfig，在init的方法中将局部变量赋值给实例变量，将getServletConfig方法中返回实例变量ServletConfig供子类使用</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!-- 创建在servlet标签中--&gt;</span><br><span class="hljs-comment">&lt;!-- 初始化参数--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- 初始化参数名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>namespace<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- 初始化参数值--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h3><ol>
<li><p>Http协议就是指客户端和服务器之间通信时发送的数据，需要遵守的规则</p>
</li>
<li><p>Http协议中的数据又叫报文</p>
</li>
<li><p>客户端给服务器发送数据叫请求，服务器给客户端回传数据叫响应</p>
</li>
<li><p>请求分为GET请求和POST请求           </p>
<p>get请求会被浏览器缓存，要想不缓存可以再请求路径中加时间，改变每次请求的请求路径</p>
<p><strong>GET请求</strong>  不太安全 请求体在URL地址栏</p>
<ol>
<li><p>请求行（包含了POST请求请求体中的参数）</p>
<p>请求的方式， 请求的资源路径， 请求的协议版本号</p>
</li>
<li><p>消息报头</p>
<p>key:value 组成（不同的键值对，表示不同的含义）</p>
<p>Accept：告诉服务器客户端可以接收的数据类型</p>
<p>Accept-Language：告诉服务器客户端可以接收的语言</p>
<p>User-Agent：浏览器的信息</p>
<p>Accept-Encoding：告诉服务器客户端可以接收的数据编码格式</p>
<p>Host：表示请求的服务器ip和端口号</p>
<p>Connection：告诉服务器请求的链接如何处理（Keep-Alive 回传数据不要马上关闭连接一段时间， Closed 马上关闭）</p>
</li>
</ol>
<p><strong>POST请求</strong>  相对安全  只有表单form标签中设置为post请求时才是post请求</p>
<ol>
<li><p>请求行</p>
<p>请求的方式， 请求的资源路径， 请求的协议版本号</p>
</li>
<li><p>消息报头</p>
<p>key:value 组成（不同的键值对，表示不同的含义）</p>
<p>Accept：告诉服务器客户端可以接收的数据类型</p>
<p>Accept-Language：告诉服务器客户端可以接收的语言</p>
<p>Referer：发起请求时，浏览器地址栏中的地址</p>
<p>User-Agent：浏览器的信息</p>
<p>Content-Type：发送的数据的类型</p>
<p>Accept-Encoding：告诉服务器客户端可以接收的数据编码格式</p>
<p>Host：表示请求的服务器ip和端口号</p>
<p>Connect-Length：发送的数据的长度</p>
<p>Connection：告诉服务器请求的链接如何处理（Keep-Alive 回传数据不要马上关闭连接一段时间， Closed 马上关闭）</p>
<p>Cache-Control：控制缓存</p>
</li>
<li><p>空白行</p>
</li>
<li><p>请求体（发送给服务器的数据参数）</p>
</li>
</ol>
<p>响应</p>
<ol>
<li>状态行（协议版本号 状态码 状态描述信息）</li>
<li>响应报头</li>
<li>空白行</li>
<li>响应体</li>
</ol>
<p>响应码：</p>
<ol>
<li>1xx：服务器接收客户端消息，但没有接收完成</li>
<li>2xx：成功</li>
<li>3xx：重定向</li>
<li>4xx：客户端错误</li>
<li>5xx：服务器错误</li>
</ol>
</li>
</ol>
<h3 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h3><h4 id="浏览器乱码"><a href="#浏览器乱码" class="headerlink" title="浏览器乱码"></a>浏览器乱码</h4><ol>
<li>html中：&lt;meta content&#x3D;”text&#x2F;html;charset&#x3D;UTF-8””&gt;</li>
<li>经过Servlet之后：response.setContentType(“text&#x2F;html;charset&#x3D;UTF-8”);</li>
</ol>
<h4 id="服务器乱码"><a href="#服务器乱码" class="headerlink" title="服务器乱码"></a>服务器乱码</h4><p>resquest.setCharacterEncoding(“UTF-8”)：只适合POST请求，只对请求体进行编码</p>
<h3 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h3><p>给服务器使用的路径不需要加虚拟目录（项目的访问路径）</p>
<p>给浏览器使用的需要加虚拟目录【请求从哪来路径就是给谁使用】</p>
<p>base标签：设置页面相对路径工作时参照的地址</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">常用的路径：<br>1. <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/项目名/资源路径&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>2. <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/项目名/资源路径&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>3. cookie.setPath(&quot;/项目名/资源路径&quot;)<br>4. 重定向：response.getRequestDispatcher(&quot;/资源路径&quot;).forward(request, reponse)<br>5. 欢迎页面：资源路径<br>6. servlet路径：/自定义资源路径<br></code></pre></td></tr></table></figure>



<h3 id="欢迎页面"><a href="#欢迎页面" class="headerlink" title="欢迎页面"></a>欢迎页面</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>页面名称<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>欢迎页面可以设置多个，按照编写顺序从上到下访问，如果上边的页面资源不存在时，才会访问下边的资源</p>
</li>
<li><p>页面名称：以webapp根目录的文件开始，但不用以&#x2F;开始</p>
</li>
<li><p>欢迎页面有全局配置和局部配置</p>
<p>​	全局配置：conf&#x2F;web.xml</p>
<p>​	局部配置：webapp&#x2F;WEB-INF&#x2F;web.xml</p>
</li>
</ol>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><ol>
<li><p>会话：一次会话中包含多次请求和多次响应（浏览器第一次给服务器发送请求会话建立，直到一方断开为止）</p>
<p>本质上是session对象销毁时会话才会结束，session销毁之前可以通过复写URL的JSESSIONID的方式可以访问之前的会话，但要直到session对应的cookie中的JSESSIONID的值</p>
</li>
<li><p>功能：在一次会话的范围内的多次请求间共享数据，对个request之间共享数据</p>
</li>
</ol>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>cookie是http协议的，只是Tomcat中将cookie封装成了类</p>
<ol>
<li><p>功能：将数据保存在客户端</p>
</li>
<li><p>使用步骤：</p>
<ol>
<li>创建Cookie对象，绑定数据   	new Cookie(String name, String value)</li>
</ol>
</li>
<li><p>发送Cookie对象，服务器将Cookie数据放到响应头中，响应给浏览器（例如：set-cookie:name&#x3D;value）         response.addCookie(Cookie cookie)</p>
<ol start="3">
<li>获取Cookie对象，浏览器将Cookie数据放到请求头中，发送给服务器（例如：cookie:name&#x3D;value）拿到数据          Cookie[]   requst.getCookies()</li>
</ol>
<p>就相当于输入输出流，获取文件（输入流&#x2F;获取cookie对象），修改文件（修改cookie对象的name或value），响应文件（输出流&#x2F;添加cookie对象）</p>
</li>
<li><p>一次可以发送多个cookie，创建多个cookie对象</p>
</li>
<li><p>默认情况下，Cookie存储在浏览器缓存中，当浏览器关闭后，Cookie数据被销毁</p>
<p>持久化储存： setMaxAge(int seconds)    </p>
<p>​	seconds为整数时表示将Cookie数据写入到磁盘文件中seconds秒的时间</p>
<p>​	seconds为负数时表示默认值，关闭浏览器，Cookie数据销毁</p>
<p>​	seconds为0时表示删除Cookie数据信息</p>
</li>
<li><p>默认情况下Cookie数据不能在Tomcat中的web项目共享</p>
<ol>
<li><p>setPath(String path)设置cookie数据的获取范围，cookie数据绑定路径，默认为当前的虚拟目录，“&#x2F;”表示cookie可以共享到整个Tomcat服务器中</p>
</li>
<li><p>setDomain(String path)设置一级域名相同，多个服务器之间cookie共享</p>
<p>比如：setDomain(“.baidu.com”)，tieba.baidu.com和news.baidu.com之间的cookie数据共享</p>
</li>
</ol>
</li>
<li><p>作用：cookie数据存储在客户端浏览器，并且对于单个cookie的大小有限制(4kb)对于同一域名下的总cookie数量也有限制(20个)</p>
<p>cookie一般用于存储少量的不太敏感的数据，在不登录的情况下，完成服务器对客户端的身份识别</p>
</li>
</ol>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><ol>
<li><p>服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端HttpSession对象中。</p>
</li>
<li><p>使用步骤：</p>
<ol>
<li><p>获取HttpSession对象，没有则创建新的session对象   HttpSession session &#x3D; request.getSession();    </p>
<p> 获取session对象，没有获取到则返回空    request.getSession(false);</p>
</li>
<li><p>常用方法</p>
<p>Object getAttribute(String name)      设置域数据        <strong>整个会话共享</strong></p>
<p>void setAttribute(String name, Object value)      获取域数据</p>
<p>void removeAttribute(String name)       删除域数据</p>
<p>void invalidate()    销毁session对象</p>
</li>
</ol>
</li>
<li><p>客户端和浏览器都不关闭时（会话不结束时），每次请求获取的session对象是同一个session对象</p>
</li>
<li><p>原理：</p>
<p>Session的实现依赖于Cookie，浏览器首次请求时会话建立，创建一个HttpSession对象，同时生成session对象对应的cookie对象，cookie对象的key是JSESSIONID，value是32位的字符串，将cookie对象的value字符串值和session对象绑定到session的map列表中，每次请求浏览器向服务器发送cookie，服务器查找session列表找到cookie对象中key值对应的session对象，响应给session</p>
</li>
<li><p>服务器中的session对象销毁是遵循超时销毁规则的，默认是会话结束30分钟内没有会话建立时，session销毁，可以在web.xml文件中设置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>时间<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>默认情况下，客户端关闭，服务器不关闭，两次获取的session不是同一个</p>
<p>可以创建Cookie，键为<strong>JSESSIONID</strong>，设置存活时间，让cookie持久化保存</p>
<p>Cookie c &#x3D; new Cookie(“JSESSIONID”, session.getId());</p>
<p>c.setMaxAge(seconds);</p>
<p>reponse.addCookie(c);</p>
</li>
<li><p>客户端不关闭，服务器关闭，两次获取的session不是同一个</p>
<p>虽然不是同一个但是要确保数据不会丢失</p>
<p>​	session的钝化：在服务器正常关闭前，将session对象序列化到硬盘上</p>
<p>​	session的活化：在服务器启动后，将session文件转换为内存中的session对象</p>
</li>
<li><p>特点：</p>
<ol>
<li>session用于存储一次会话的多次请求的数据，存储在服务器</li>
<li>session可以存储任意类型，任意大小的数据</li>
</ol>
</li>
</ol>
<h2 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h2><p>作用：当访问服务器的资源时，过滤器可以将请求和响应拦截下来，完成一些特殊功能；比如登录验证，统一编码处理，敏感字符过滤</p>
<h3 id="FilterConfig"><a href="#FilterConfig" class="headerlink" title="FilterConfig"></a>FilterConfig</h3><p>Filter的配置信息类，相当于ServletConfig</p>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">filterConfig.getFilterName()：获取Filter的Name<br>filterConfig.getInitParameterNames()：获取所有的初始化参数名称<br>filterConfig.getInitParameter(name)：获取name对应的value值<br>filterConfig.getServletContext()：获取全局域对象<br></code></pre></td></tr></table></figure>

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>定义一个类，实现接口Filter</p>
</li>
<li><p>复写方法doFilte()方法拦截：在方法中调用filterChain.doFilter()将拦截的资源放行</p>
</li>
<li><p>配置拦截路径</p>
<ol>
<li>web.xml</li>
<li>注解：注解中写的是要拦截的路径  @WebFilter()</li>
</ol>
</li>
</ol>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol>
<li>执行过滤器</li>
<li>执行放行后的资源</li>
<li>回来执行过滤器放行后的代码</li>
</ol>
<h3 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h3><ol>
<li>服务器启动创建Filter对象</li>
<li>init：执行init方法，只执行一次</li>
<li>doFilter：每次请求被拦截资源时被执行</li>
<li>destroy：在服务器关闭时，Filter对象被销毁，正常关闭服务器会执行destroy方法</li>
</ol>
<h3 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h3><p>注解的value属性或web.xml中&lt; usl-pattern&gt;拦截路径&lt; &#x2F;usl-pattern&gt;</p>
<ol>
<li>具体资源路径：&#x2F;index.jsp</li>
<li>拦截目录：&#x2F;user&#x2F;*</li>
<li>后缀名拦截：*.jsp</li>
<li>拦截所有的资源：&#x2F;*</li>
</ol>
<h3 id="拦截方式"><a href="#拦截方式" class="headerlink" title="拦截方式"></a>拦截方式</h3><p>资源被访问的方式</p>
<ol>
<li><p>注解：@WebFilter()</p>
<p>设置dispatcherTypes属性</p>
<ol>
<li>REQUEST：默认值，浏览器直接访问资源</li>
<li>FORWARD：转发访问资源</li>
<li>INCLUDE：包含访问资源</li>
<li>ERROR：错误跳转资源</li>
<li>ASYNC：异步访问资源</li>
</ol>
</li>
<li><p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>name<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>全限定类名<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>name<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">usl-pattern</span>&gt;</span>拦截路径<span class="hljs-tag">&lt;/<span class="hljs-name">usl-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dispatcher</span>&gt;</span>拦截方式<span class="hljs-tag">&lt;/<span class="hljs-name">dispatcher</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><p>配置多个过滤器</p>
<p>执行顺序：过滤器1， 过滤器2， 资源， 过滤器2， 过滤器1</p>
<p>过滤器先后顺序配置：</p>
<p>​	注解配置：按照类名的字符串比较规则比较，值小的先执行</p>
<p>​	web.xml配置：谁定义在上边，谁先执行</p>
<h2 id="Listener监听器"><a href="#Listener监听器" class="headerlink" title="Listener监听器"></a>Listener监听器</h2><p>事件监听机制</p>
<p>​	事件		：一个事情</p>
<p>​	事件源	：事件发生的地方</p>
<p>​	监听器	：一个对象</p>
<p>​	注册监听：将事件、事件源、监听器绑定在一起。当事件源发生在某个事件后，执行监听器代码</p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>定义一个类，实现ServletContextListener接口</p>
</li>
<li><p>复写方法</p>
<p>void contextInitialized(ServletContextEvent sce)：监听对象创建前调用</p>
<p>void contextDestroyed(ServletContextEvent sce)：监听对象销毁前调用</p>
</li>
<li><p>配置：web.xml    或     注解@WebListener</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">lstener-class</span>&gt;</span>全限定类名<span class="hljs-tag">&lt;/<span class="hljs-name">lstener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><p>jsp是javaEE规范之一，jsp底层其实就是java程序，会服务器会将jsp文件翻译成java类，在将java类进行编译</p>
<p>jsp主要是做页面展示的，修改之后Tomcat会自动部署，根据jsp文件的最后修改时间判断是否重新部署</p>
<p><strong>JSP脚本</strong>：JSP定义java代码的方式</p>
<ol>
<li>&lt;% 代码 %&gt;：在service方法中可以定义的代码，在该脚本中都可以定义</li>
<li>&lt;%! 代码 %&gt;：在类成员位置可以定义的代码，在该脚本中都可以定义</li>
<li>&lt;%&#x3D; 代码 %&gt;：在输出语句中可以定义的数据，在该脚本中都可以定义，相当于out.print(“”);</li>
</ol>
<p><strong>注释</strong>：</p>
<!--  -->：HTML注释，JSP会翻译成字符串发送到浏览器，用户可以在浏览器中查看到

<p>&lt;%–  –%&gt;：Tomcat服务器在编译时忽略JSP注释</p>
<p><strong>指令</strong>：指导JSP的翻译引擎如何翻译JSP代码</p>
<p>语法：&lt;%@ 指令名称 属性名&#x3D;属性值 属性名&#x3D;属性值….  %&gt;</p>
<p><strong>page</strong>：配置JSP页面</p>
<p>常用属性：</p>
<ol>
<li>contentType：设置JSP响应时的mime类型以及字符集          等同于respons.setContentType() </li>
<li>pageEncoding：设置JSP响应时的字符编码</li>
<li>session：true表示当前JSP可以直接使用内置对象session，程序执行获取当前session对象，没有获取到则新建session对象；false表示不能直接使用内置对象，要想使用要使用getSession()获取session对象</li>
<li>import：导包</li>
<li>errorPage：当前页面发生异常后，会自动跳转到指定的错误页面</li>
<li>isErrorPage：标识当前页面是否为错误页面（是就可以使用内置对象exception）</li>
<li>isELIgnored：是否忽略EL表达式</li>
</ol>
<p><strong>include</strong>：页面包含的，导入页面的资源          编译期包含，翻译成一个java源文件，静态联编</p>
<ol>
<li>file：跳转的资源路径                    可以将网页头网页脚等固定不变的单独写到剪JSP文件中</li>
</ol>
<p><strong>taglib</strong>：导入资源，引入标记库</p>
<p><strong>动作</strong>：&lt;jsp:动作名 属性名&#x3D;属性值 属性名&#x3D;属性值&gt;&lt;&#x2F;jsp:动作名 &gt;</p>
<p><strong>forward</strong>：转发，跳转页面</p>
<p><strong>include</strong>：页面包含，生成了两个java源文件，动态联编</p>
<p><strong>内置对象</strong>：在jsp页面不用创建直接使用，只能在service方法中直接使用，在&lt;%%&gt;中直接使用</p>
<ol>
<li>pageContext		PageContext 	                	当前页面共享数据，还可以获取其他八个内置对象</li>
<li>request                 HttpServletRequest             同一个请求中共享数据</li>
<li>session                 HttpSession                          同一个会话中共享数据</li>
<li>application           ServletContext                     所有用户间共享数据</li>
<li>response               HttpServletResponse         响应对象</li>
<li>page                      Object                                    当前Servlet对象，相当于this</li>
<li>out                         JSPWriter                               输出对象，数据输出到页面上</li>
<li>config                    ServletConfig                        Servlet的配置对象</li>
<li>exception              Throwable                            异常对象</li>
</ol>
<h3 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h3><p>作用：替换和简化页面中的java的代码</p>
<p>语法：${表达式}</p>
<p>使用：</p>
<ol>
<li><p>运算符：将获取值进行运算</p>
<p>算术运算符，比较运算符，逻辑运算符，三目运算符，空运算符（empty用来判断字符串、集合、数组对象是否为null并且长度是否为0）</p>
</li>
<li><p>获取值：EL表达式只能从域对象中获取值</p>
<ol>
<li><p>${域名称.键名}：从指定域中获取指定键的值</p>
</li>
<li><p>${键名}：依次从小到大的域中查找是否含有该键对应的值</p>
</li>
<li><p>${域名称.键名.属性名}：获取对象的属性值，本质上会调用对象的getter方法，没有getter方法获取不到</p>
<p>${域名称.键名[索引]}：根据索引获取List集合中的值</p>
<p>${域名称.键名.key名称}或${域名称.键名[“key名称”]}：通过key获取Map集合中的value</p>
</li>
</ol>
</li>
</ol>
<p>隐式对象</p>
<table>
<thead>
<tr>
<th align="left"><strong>隐含对象</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">pageScope</td>
<td align="left">page 作用域</td>
</tr>
<tr>
<td align="left">requestScope</td>
<td align="left">request 作用域</td>
</tr>
<tr>
<td align="left">sessionScope</td>
<td align="left">session 作用域</td>
</tr>
<tr>
<td align="left">applicationScope</td>
<td align="left">application 作用域</td>
</tr>
<tr>
<td align="left">param</td>
<td align="left">Request 对象的参数，字符串</td>
</tr>
<tr>
<td align="left">paramValues</td>
<td align="left">Request对象的参数，字符串集合</td>
</tr>
<tr>
<td align="left">header</td>
<td align="left">HTTP 信息头，字符串</td>
</tr>
<tr>
<td align="left">headerValues</td>
<td align="left">HTTP 信息头，字符串集合</td>
</tr>
<tr>
<td align="left">initParam</td>
<td align="left">上下文初始化参数</td>
</tr>
<tr>
<td align="left">cookie</td>
<td align="left">Cookie值</td>
</tr>
<tr>
<td align="left">pageContext</td>
<td align="left">当前页面的pageContext</td>
</tr>
</tbody></table>
<p>${pageContext.request.contextPath}：通过pageContext获取当前页面的request内置对象，动态获取虚拟目录</p>
<h3 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h3><p>使用之前要导入JSTL相关jar包</p>
<p>引入标签库：taglib指令：&lt;%@ taglib perfix&#x3D;”c” uri&#x3D;”<a target="_blank" rel="noopener" href="http://java.sun.com/jsp/jstl/core&quot;">http://java.sun.com/jsp/jstl/core&quot;</a> %&gt;</p>
<p>&lt;c:**if** test&#x3D;”EL表达式条件”&gt;内容</p>
<p>&lt;c:if test&#x3D;”EL表达式条件”&gt;：相当于java代码的if语句</p>
<p>​	test属性：接收boolean表达式，如果表达式为true，则显示标签内的内容</p>
<p>&lt;c:**choose** &gt;</p>
<p>&lt;c:when test&#x3D;”EL表达式条件”&gt;内容</p>
<p>&lt;c:otherwise &gt;内容</p>
<p></p>
<p>&lt;c:choose &gt;：相当于java代码的switch语句</p>
<p>&lt;c:when test&#x3D;”EL表达式条件”&gt;：相当于case语句</p>
<p>test属性：接收表达式</p>
<p>&lt;c:otherwise &gt;相当于default语句</p>
<p>for(int i &#x3D; 0; i &lt; 10; i++)对应JSTL标签</p>
<p>&lt;c:**foreach** var&#x3D;”i” begin&#x3D;”0” end&#x3D;”9” serp&#x3D;”1”&gt;</p>
<p>属性：</p>
<p>​	var：声明循环变量i———-相当于i</p>
<p>​	begin：初始化循环变量i———-相当于i&#x3D;0</p>
<p>​	end：循环变量i的最大值———-相当于i&lt;10</p>
<p>​	step：步长———-相当于i++</p>
<p>​	varStatus：循环状态对象</p>
<p>​		index：容器中元素的索引，从0开始</p>
<p>​		count：循环次数，从1开始</p>
<p>for (User user : list)对应的jstl标签。    <strong>遍历的必须是集合类型的，否则遍历出错</strong></p>
<p>&lt;c:**foreach** items&#x3D;”EL表达式获取集合容器” var&#x3D;”自定义名称key”&gt;${key.属性名}</p>
<p>属性：</p>
<p>items：容器对象，相当于list</p>
<p>var：容器中元素的临时变量，相当于user</p>
<p>varStatus：循环状态对象</p>
<p>​		index：容器中元素的索引，从0开始</p>
<p>​		count：循环次数，从1开始</p>
<h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>一个JavaScript框架，是js库，简化JS的开发</p>
<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><p>导入jQuery的min.js文件（min.js生产版本，js开发版本）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script typr=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;JQuery文件路径&quot;</span>&gt; &lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>jQuery对象和JS对象的转换</p>
<p>​	jQuery —&gt;JS：jQuery对象[索引]   或  jQuery对象.get(索引)</p>
<p>​	JS—&gt;jQuery：$(JS对象)</p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>就是一个字符串，用来定位dom对象，筛选具有相似特征的元素（标签）</p>
<h4 id="标签选择器（元素选择器）"><a href="#标签选择器（元素选择器）" class="headerlink" title="标签选择器（元素选择器）"></a>标签选择器（元素选择器）</h4><p>$(“html标签名”)：获得所有匹配标签名称的元素</p>
<h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><p>$(“#id的属性值”)：获得与指定id属性值匹配的元素</p>
<h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><p>$(“.class的属性值”)：获得与指定class属性值匹配的元素</p>
<h4 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h4><p>$(“选择器1, 选择器2, …..”)</p>
<h4 id="表单选择器"><a href="#表单选择器" class="headerlink" title="表单选择器"></a>表单选择器</h4><p>$(“:type属性值”)：获取该属性的所有值（input标签的type属性值：text，password，radio，checkbox）</p>
<h4 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h4><p>$(“父选择器 &gt; 子选择器”)</p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>定位dom对象后，根据一些条件筛选dom对象，过滤器不能单独使用，必须和选择器一起使用</p>
<h4 id="“选择器-first”"><a href="#“选择器-first”" class="headerlink" title="$(“选择器:first”)"></a>$(“选择器:first”)</h4><p>选出第一个dom对象</p>
<h4 id="“选择器-last”"><a href="#“选择器-last”" class="headerlink" title="$(“选择器:last”)"></a>$(“选择器:last”)</h4><p>选出最后一个dom对象</p>
<h4 id="“选择器-eq-数组下标-”"><a href="#“选择器-eq-数组下标-”" class="headerlink" title="$(“选择器:eq(数组下标)”)"></a>$(“选择器:eq(数组下标)”)</h4><p>获取指定下标的dom对象</p>
<h4 id="“选择器-lt-下标-”"><a href="#“选择器-lt-下标-”" class="headerlink" title="$(“选择器:lt(下标)”)"></a>$(“选择器:lt(下标)”)</h4><p>获取小于下标的所有dom对象</p>
<h4 id="“选择器-gt-下标-”"><a href="#“选择器-gt-下标-”" class="headerlink" title="$(“选择器:gt(下标)”)"></a>$(“选择器:gt(下标)”)</h4><p>获取大于下标的所有dom对象</p>
<h4 id="“-text-enabled”"><a href="#“-text-enabled”" class="headerlink" title="$(“:text:enabled”)"></a>$(“:text:enabled”)</h4><p>获取表单中启用的文本框的dom对象</p>
<h4 id="“-text-disabled”"><a href="#“-text-disabled”" class="headerlink" title="$(“:text:disabled”)"></a>$(“:text:disabled”)</h4><p>获取表单中停用的文本框的dom对象</p>
<h4 id="“-checkbox-checked”"><a href="#“-checkbox-checked”" class="headerlink" title="$(“:checkbox:checked”)"></a>$(“:checkbox:checked”)</h4><p>获取表单中选中的复选框</p>
<h4 id="“选择器-gt-option-selected”"><a href="#“选择器-gt-option-selected”" class="headerlink" title="$(“选择器&gt;option:selected”)"></a>$(“选择器&gt;option:selected”)</h4><p>获取表单中选中的下拉列表框</p>
<h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><h4 id="选择器-事件名称-事件的处理函数"><a href="#选择器-事件名称-事件的处理函数" class="headerlink" title="$(选择器).事件名称(事件的处理函数)"></a>$(选择器).事件名称(事件的处理函数)</h4><p>在进行时间绑定时必须保证页面已经下载完毕，所以需要$(function(){……..});在这里进行函数时间绑定  </p>
<p>$(选择器)：定位dom对象。dom对象可以有多个</p>
<p>事件名称：就是js中时间去掉on的部分（js中的单击事件onclick()，jQuery中的时间名称就是click()）</p>
<p>事件的处理函数：就是一个function(){函数体;}，当事件发生时执行该函数</p>
<h4 id="选择器-on-“事件名称”-事件的处理函数"><a href="#选择器-on-“事件名称”-事件的处理函数" class="headerlink" title="$(选择器).on(“事件名称”, 事件的处理函数)"></a>$(选择器).on(“事件名称”, 事件的处理函数)</h4><p>事件名称：就是js中时间去掉on的部分（js中的单击事件onclick()，jQuery中的时间名称就是click()）</p>
<p>事件的处理函数：就是一个function(){函数体;}，当事件发生时执行该函数</p>
<h4 id="选择器-off-“事件名称”"><a href="#选择器-off-“事件名称”" class="headerlink" title="$(选择器).off(“事件名称”)"></a>$(选择器).off(“事件名称”)</h4><p>解除事件的绑定</p>
<p>事件名称：就是js中时间去掉on的部分（js中的单击事件onclick()，jQuery中的时间名称就是click()）</p>
<h4 id="选择器-css-“属性”-“值”"><a href="#选择器-css-“属性”-“值”" class="headerlink" title="$(选择器).css(“属性”, “值”)"></a>$(选择器).css(“属性”, “值”)</h4><p>样式控制</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="val"><a href="#val" class="headerlink" title="val()"></a>val()</h4><p>操作数组中dom对象的value属性</p>
<p>$(选择器).val()：无参数调用形式，获取数组中第一个dom对象的value值</p>
<p>$(选择器).val(“参数”)：有参数形式调用，统一对数组中所有dom对象的value属性值进行赋值</p>
<h4 id="text"><a href="#text" class="headerlink" title="text()"></a>text()</h4><p>操作数组中所有dom对象的文字显示内容形式</p>
<p>$(选择器).text()：无参数调用形式，读取数组中所有dom对象的文字显示内容，并将所有内容拼接成一个字符串</p>
<p>$(选择器).text(参数)：有参数调用形式，对数组中的所有dom对象的文字显示内容进行统一赋值</p>
<h4 id="attr"><a href="#attr" class="headerlink" title="attr()"></a>attr()</h4><p>对val，text之外的其他属性进行操作</p>
<p>$(选择器).attr(“属性名”)：获取数组中第一个dom对象的属性值</p>
<p>$(选择器).attr(“属性名”,”属性值”)：对数组中所有dom对象的属性赋值</p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>$(选择器).remove()：删除数组中所有dom对象及其子对象</p>
<h4 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h4><p>$(选择器).empty()：删除数组中所有dom对象的子对象，该dom对象并不删除</p>
<h4 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h4><p>为数组中所有dom对象添加子对象</p>
<p>$(选择器).append(“<div>div内容</div>“)：添加了子对象div</p>
<h4 id="html"><a href="#html" class="headerlink" title="html()"></a>html()</h4><p>设置或返回被选元素的内容   （html能识别html标签，text不能识别html标签）</p>
<p>$(选择器).html()：无参数形式调用，获取数组中第一个dom对象的内容</p>
<p>$(选择器).html(参数)：有参数形式调用，用于设置数组中所有dom对象的内容</p>
<h4 id="each"><a href="#each" class="headerlink" title="each()"></a>each()</h4><p>对数组，json和dom数组进行遍历，对每个元素调用一次函数</p>
<p>$.each(遍历的对象，function(index, element){程序;})：index是遍历的次数，element是遍历的元素内容</p>
<p>jQuery对象.each(function(index, element){程序;})：index是遍历的次数，element是遍历的元素内容</p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>异步的javascript和XML</p>
<p>异步和同步：客户端和服务器端相互通信的基础上</p>
<p>异步：客户端不需要保持等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作</p>
<h3 id="JS实现方式"><a href="#JS实现方式" class="headerlink" title="JS实现方式"></a>JS实现方式</h3><p>步骤：</p>
<ol>
<li><p>创建AJAX异步对象XMLHttpRequest，XMLHttpRequest对象可以在浏览器当中单独开启一个线程，接收和响应数据都在异步对象XMLHttprequest中，使用异步对象的responseText属性以字符串的形式获取响应的数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">XMLHttpRequest</span>)&#123;<br>	xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>	<span class="hljs-comment">//IE5和IE6使用AvtiveXObject</span><br>	xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveXObject</span>(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>注册回调函数，给异步对象绑定事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//程序指定到这里，程序不会执行，只是将回调函数注册给异步对象，等异步对象的readyState属性改变时，回调函数才会执行（readyState属性属性值改变就会调用一次回调函数）</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>	<span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyStart</span> == <span class="hljs-number">4</span>)&#123;<span class="hljs-comment">//服务器响应结束</span><br>        <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>)&#123;<span class="hljs-comment">//200表示服务器正常响应结束</span><br>            <span class="hljs-comment">//在浏览器端接收服务器端响应的文本</span><br>            <span class="hljs-keyword">var</span> s = xhr.<span class="hljs-property">responseText</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-title function_">alert</span>(xhr.<span class="hljs-property">status</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>开启浏览器和服务器之间的通道</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//method：指定请求方式为get还是put</span><br><span class="hljs-comment">//url：请求路径,get请求在url后加?提交</span><br><span class="hljs-comment">//asyn：true/false（true：支持异步，false：支持同步）</span><br>xhr.<span class="hljs-title function_">open</span>(method, url, asyn);<br></code></pre></td></tr></table></figure>
</li>
<li><p>发送AJAX请求js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//此时才会发送请求,get请求</span><br>xhr.<span class="hljs-title function_">send</span>();<br>   <br><span class="hljs-comment">//此时才会发送请求,post请求在这提交数据</span><br><span class="hljs-comment">//post请求时要写，模拟form表单提交数据</span><br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded;charset=UTF-8&quot;</span>);<br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;数据&quot;</span>);<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="JQeury实现方式"><a href="#JQeury实现方式" class="headerlink" title="JQeury实现方式"></a>JQeury实现方式</h3><h4 id="ajax-名称-值-名称1-值1……-名称-值之间不能存在空格"><a href="#ajax-名称-值-名称1-值1……-名称-值之间不能存在空格" class="headerlink" title="$.ajax({名称:值, 名称1:值1…….})     名称:值之间不能存在空格"></a>$.ajax({名称:值, 名称1:值1…….})     名称:值之间不能存在空格</h4><p>url:”路径”：请求路径</p>
<p>type:get&#x2F;post：请求方式</p>
<p>async:true&#x2F;false：设置是否是异步请求</p>
<p>data:{“username”:”zhq”,  ….. }：请求参数（json或数组）</p>
<p>dataType:””：设置接收到的响应数据的格式，将接收的数据进行相应的格式转化（xml，HTML，text，json）</p>
<p>success:function(a){alert(a)}：响应成功后回调函数</p>
<p>error:function(a){alert(a)}：响应错误后回调函数</p>
<h4 id="get-“url”-data-function-“dataType”"><a href="#get-“url”-data-function-“dataType”" class="headerlink" title="$.get(“url”, data, function(){}, “dataType”)"></a>$.get(“url”, data, function(){}, “dataType”)</h4><p>url：请求路径</p>
<p>data:{“username”:”zhq”,  ….. }：请求参数（json或数组）</p>
<p> function(resp){}：回调函数</p>
<p>dataType:””：设置接收到的响应数据的格式，将接收的数据进行相应的格式转化（xml，HTML，text，json）</p>
<h4 id="post-“url”-data-function-“dataType”"><a href="#post-“url”-data-function-“dataType”" class="headerlink" title="$.post(“url”, data, function(){}, “dataType”)"></a>$.post(“url”, data, function(){}, “dataType”)</h4><p>url：请求路径</p>
<p>data：{“username”:”zhq”,  ….. }请求参数（json或数组）</p>
<p> function(resp){}：回调函数</p>
<p>dataType：设置接收到的响应数据的格式，将接收的数据进行相应的格式转化（xml，HTML，text，json）</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>JavaScript的标记对象，多用于存储和交换文本信息的语法。轻量级的交换数据格式</p>
<p>JSON在线工具验证</p>
<h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p>在javascript数据存储在 名称&#x2F;值 对中：json数据由键值对构成</p>
<p>键：可以用引号引起来，单双都可</p>
<p>值：</p>
<p>​	数字（整数或浮点数）； </p>
<p>​	字符串（在双引号中）；</p>
<p>​	逻辑值（true或false）；</p>
<p>​	数组（在方括号中）   {“name”:[{}, {}, {}]}；</p>
<p>​	对象（在花括号中）   {“name”:{“name”:” “}}；</p>
<p>​	null</p>
<p>数据由逗号分隔：多个键值对由对号分隔</p>
<p>花括号保存对象：使用{}定义json格式</p>
<p>方括号保存数组：[]</p>
<h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><p>在javascript中使用**window.eval(JSON字符串)**解释执行java生成的JSON格式的字符串</p>
<ol>
<li><p>json对象.键名</p>
</li>
<li><p>json对象[“键名”]</p>
</li>
<li><p>数组对象[索引]：数组对象相当于键名</p>
</li>
<li><p>遍历p对象的键和值</p>
<p>for (var key in p){</p>
<p>​	alert(key+”:”+p[key])</p>
<p>}</p>
</li>
</ol>
<h4 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h4><p>JSON格式的字符串和java对象的相互转换        JSON解析器：jackson（Spring框架内部解析器）</p>
<ol>
<li><p>JSON格式的字符串转为Java对象</p>
<ol>
<li>导入jackson的相关jar包</li>
<li>创建jackson核心对象ObjectMapper</li>
<li>调用ObjectMapper的**readValue(json字符串数据，Class类型)**进行转化</li>
</ol>
</li>
</ol>
<p>Java对象转为JSON格式的字符串</p>
<ol>
<li><p>导入jackson的相关jar包</p>
</li>
<li><p>创建jackson核心对象ObjectMapper</p>
</li>
<li><p>调用ObjectMapper的相关方法进行转换</p>
<ol>
<li><p>writeValue(参数，obj)：</p>
<p>​	参数：</p>
<p>​		File：将obj对象转化为json字符串，并保存到指定的文件中</p>
<p>​		Writer：将obj对象转化为json字符串，并将json数据填充到字符输出流中</p>
<p>​		OutputStream：将obj对象转化为json字符串，并将json数据填充到字节输出流中</p>
</li>
<li><p>writeValueAsString(obj)：将对象转化为json字符串       （List转成的是数组，Map转成的就是对象格式）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>objectMapper.writeValueAsString(java对象);<br></code></pre></td></tr></table></figure>
</li>
<li><p>注解</p>
<ol>
<li>@JsonIgnore：排除属性，对应的对象属性不会转化为JSON字符串属性</li>
<li>@JsonFormat(pattern&#x3D;”格式”)：将对应的对象属性转化为JSON字符串时进行格式化</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ol>
<li>xml文档后缀名为.xml</li>
<li>xml的第一行必须定义为文档声明</li>
<li>xml文档中有且仅有一个根标签</li>
<li>属性值必须使用引号引起来</li>
<li>标签必须正确关闭</li>
<li>xml标签名称区分大小写</li>
</ol>
<h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ol>
<li><p>文档声明</p>
<ol>
<li><p>格式：<?xml 属性列表 ?></p>
</li>
<li><p>属性列表</p>
<p>​	version：版本号</p>
<p>​	encoding：编码方式，告知解析引擎当前文档使用的字符集，默认为ISO-8859-1</p>
<p>​	standalone：是否独立（yes&#x2F;no）</p>
</li>
</ol>
</li>
<li><p>指令：结合CSS的</p>
</li>
<li><p>标签：标签名称自定义</p>
<p>​	规则：</p>
<p>​		名称可以包含字母数字和其他字符</p>
<p>​		名称不能一数字或标点符号开头，不能以xml开头</p>
<p>​		名称不能包含空格</p>
</li>
<li><p>属性：id属性值唯一</p>
</li>
<li><p>文本：CDATA区：在该区域内数据被原样展示（<!--[CDATA[数据]]-->）</p>
</li>
</ol>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>规定xml文档的抒写规则</p>
<ol>
<li><p>分类：</p>
<ol>
<li>DTD：简单的约束技术<ol>
<li>内部dtd：将约束规则定义在xml文档中</li>
<li>外部dtd：将约束的规则定义在外部dtd文件中<ol>
<li>本地：<!DOCTYPE 根标签 SYSTEM "dtd文件的位置"></li>
<li>网络：<!DOCTYPE 根标签 PUBLIC "dtd文件名" "dtd文件的位置URL"></li>
</ol>
</li>
</ol>
</li>
<li>Schema：复杂的约束技术<ol>
<li>填写xml文档的根标签</li>
<li>引入xsi前缀 xmlns:xsi&#x3D;”网络地址”;</li>
<li>引入学生的文件的命名空间 xsi:schemaLocation&#x3D;”网络地址  .xsd文件”</li>
<li>为学生的约束声明一个前缀，作为标识符  xmlns:标识 &#x3D; “网络地址”</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Jsoup解析器"><a href="#Jsoup解析器" class="headerlink" title="Jsoup解析器"></a>Jsoup解析器</h3><p>（dom方式   不用sax方式）</p>
<h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>导入jar包</li>
<li>获取Document对象</li>
<li>获取对应标签的Element对象 </li>
<li>获取数据</li>
</ol>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><h5 id="Jsoup"><a href="#Jsoup" class="headerlink" title="Jsoup"></a>Jsoup</h5><p>工具类，解析HTML或xml文档返回Document</p>
<h5 id="parse"><a href="#parse" class="headerlink" title="parse()"></a>parse()</h5><p>解析HTML或xml文档，返回Document</p>
<p>​	parse(String html)：解析xml或HTML字符串</p>
<p>​	parse(File in, String charsetName)：解析xml或HTML文件</p>
<p>​	parse(URL url, int timeoutMillis)：通过网络获取指定的xml或HTML文件</p>
<h5 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h5><p>文档对象，代表内存中的dom树，获取Element对象</p>
<p>getElementById(String id)：根据id属性获取唯一的element对象</p>
<p>getElementByTag(String tagName)：根据标签名获取元素的对象集合</p>
<p>getElementByAttribute(String key)：根据属性名获取元素的对象集合</p>
<p>getElementByAttributevalue(String key, String value)：根据属性名和属性值获取元素的对象集合</p>
<p>Elements：元素Element对象的集合，可以当做ArrayList来使用</p>
<h5 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h5><p>元素对象</p>
<ol>
<li><p>获取子元素对象</p>
<p>getElementById(String id)：根据id属性获取唯一的element对象</p>
<p>getElementByTag(String tagName)：根据标签名获取元素的对象集合</p>
<p>getElementByAttribute(String key)：根据属性名获取元素的对象集合</p>
<p>getElementByAttributevalue(String key, String value)：根据属性名和属性值获取元素的对象集合</p>
</li>
<li><p>获取属性值</p>
<p>String attr(String key)：根据属性名获取属性值</p>
</li>
<li><p>获取文本内容</p>
<p>String text()：获取文本内容</p>
<p>String hrml()：获取标签体的所有内容</p>
</li>
</ol>
<h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>结点对象是Document和Element的父类</p>
<h3 id="快捷查询"><a href="#快捷查询" class="headerlink" title="快捷查询"></a>快捷查询</h3><ol>
<li><p>selector：选择器</p>
<p>Elements select(String cssQuery)</p>
</li>
<li><p>XPath：XPath即为xml路径语言，用来确定xml文档中的某部分的位置</p>
</li>
</ol>
<h2 id="javaweb零碎知识总结"><a href="#javaweb零碎知识总结" class="headerlink" title="javaweb零碎知识总结"></a>javaweb零碎知识总结</h2><h3 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h3><p><strong>步骤：</strong></p>
<ol>
<li><p>定义一个测试类（一般定义测试类名：被测试的类名+Test， 包名：xxx.xxx.test）</p>
</li>
<li><p>定义测试方法：</p>
<p>​	该方法可以独立运行（方法名：test+测试的方法名， 返回值：void， 参数列表：空参，权限为public）</p>
</li>
<li><p>给方法加@Test注解，加Test注解才能独立运行</p>
<p>@Before注解：修饰的方法会在测试之前自动执行</p>
<p>@After注解：修饰方法会在测试方法执行后自动执行</p>
</li>
<li><p>导入Junit依赖环境，导入junit的jar包</p>
</li>
</ol>
<p><strong>结果</strong>：</p>
<p>红色表示失败， 绿色表示成功</p>
<p>用断言来处理结果而不是看输出的结果是否正确：Assert.assertEquals(期望的结果， 运算的结果)</p>
<h3 id="BeanUtils工具类"><a href="#BeanUtils工具类" class="headerlink" title="BeanUtils工具类"></a>BeanUtils工具类</h3><p>简化数据封装，用于封装javaBean的</p>
<p>BeanUtils的方法：</p>
<p>​	setProperty()：设置bean的属性值      </p>
<p>​	getProperty()：获取bean的属性值        </p>
<p>​	populate(Object obj, Map map)：将map集合的键值对信息封装到JavaBean对象中</p>
<p>javaBean是标准java类满足以下条件</p>
<ol>
<li>类必须被public修饰</li>
<li>必须提供空参public修饰的构造函数</li>
<li>成员变量必须使用private修饰</li>
<li>提供公共public修饰的setter和getter方法</li>
</ol>
<p><strong>属性</strong>就是ssetter和getter方法截取后的产物，例如getUsername() —-username就是属性</p>
<p>注意：通过Beanutils自动将提交的数据封装到对象中时，需要用到的jar包：commons-beanutils-1.8.3.jar该包需要，两个jar包的支持：commons-collections-3.2.1.jar，commons-logging-1.1.1.jar这三个包需要一起倒入，否则报错！！！</p>
<h3 id="MVC开发模式"><a href="#MVC开发模式" class="headerlink" title="MVC开发模式"></a>MVC开发模式</h3><p>M：Model，模型，JavaBean              完成集体业务操作</p>
<p>V：View，视图，JSP                             展示数据</p>
<p>C：Controller，控制器，Servlet         获取用户的输入，调用模型，将数据交给视图进行展示</p>
<h3 id="三层架构：软件设计架构"><a href="#三层架构：软件设计架构" class="headerlink" title="三层架构：软件设计架构"></a>三层架构：软件设计架构</h3><ol>
<li>界面层（表示层）：用户通过界面上的组件和服务器进行交互</li>
<li>业务逻辑层：处理业务逻辑</li>
<li>数据访问层：操作数据存储文件</li>
</ol>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JavaWeb</div>
      <div>http://example.com/2021/11/16/JavaWeb/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Beitragsautor</div>
          <div>倔强的小强</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Veröffentlicht am</div>
          <div>2021年11月16日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Urheberrechtshinweis</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/30/SpringMVC/" title="SpringMVC">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">SpringMVC</span>
                        <span class="visible-mobile">Vorheriger</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/16/Redis/" title="Redis">
                        <span class="hidden-mobile">Redis</span>
                        <span class="visible-mobile">Nächster</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Inhaltsverzeichnis</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Suchen</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Stichwort</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog funktioniert am besten mit aktiviertem JavaScript</div>
  </noscript>
</body>
</html>
